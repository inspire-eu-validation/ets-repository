<?xml version="1.0" encoding="utf-8"?>
<ExecutableTestSuite xmlns="http://www.interactive-instruments.de/etf/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="EIDacc5931c-4ff0-499f-b916-3cda1603456b" xsi:schemaLocation="http://www.interactive-instruments.de/etf/2.0 https://resources.etf-validator.net/schema/v2/val/ignoreRef.xsd">
	<itemHash>bQ==</itemHash>
	<remoteResource>http://github.com/inspire-eu-validation/ets-repository/data-au/au-dc</remoteResource>
	<localPath>/auto</localPath>
	<label>Conformance class: Data consistency, Administrative Units</label>
	<description><![CDATA[This test suite examines a data set against theme-specific requirements related to the consistency of the data.<br/><br/>
<b>This is a draft version. It has limitations and is expected to contain errors.</b> Please report any issues or problems <a href="https://github.com/interactive-instruments/ets-repository/issues" target="_blank">in GitHub</a>.<br/><br/>
Known limitations are documented in the description of the applicable test case or test assertion. There is a general limitation in all assertions that extensions in additional application schemas are only supported, if the unqualified name of the feature type in the extension is the same as the name of the feature type in the INSPIRE application schema.<br/><br/>
Source: <a href="http://inspire.ec.europa.eu/id/ats/data-au/3.1/au-dc" target="_blank">Conformance Class 'Data consistency, Administrative Units'</a><br/><br/>
Pre-requisite conformance classes:
<ul><li><a href="http://inspire.ec.europa.eu/id/ats/data/3.0rc3/data-consistency" target="_blank">Conformance Class 'Data consistency'</a></li>
</ul>]]></description>
	<reference>../../inspire-bsxets.xq</reference>
	<version>0.2.2</version>
	<author>PwC</author>
	<creationDate>2016-09-13T00:00:00Z</creationDate>
	<lastEditor>interactive instruments GmbH</lastEditor>
	<lastUpdateDate>2017-05-16T13:00:00Z</lastUpdateDate>
 	<tags>
		<tag ref="EIDfe1f3796-0ebf-4960-a6f7-f935e087fa4b"/>
	</tags>
	<testDriver ref="EID4dddc9e2-1b21-40b7-af70-6a2d156ad130"/>
	<translationTemplateBundle ref="EID70a263c0-0ad7-42f2-9d4d-0d8a4ca71b52"/>
 	<ParameterList name="ETF Standard Parameters for XML test objects">
		<parameter name="files_to_test" required="true">
			<defaultValue>.*</defaultValue>
			<description ref="TR.filesToTest"/>
			<allowedValues>.*</allowedValues>
			<type>string</type>
		</parameter>
		<parameter name="tests_to_execute" required="false">
			<defaultValue>.*</defaultValue>
			<description ref="TR.testsToExecute"/>
			<allowedValues>.*</allowedValues>
			<type>string</type>
		</parameter>
	</ParameterList>
	<supportedTestObjectTypes>
		<testObjectType ref="EIDe1d4a306-7a78-4a3b-ae2d-cf5f0810853e"/>
	</supportedTestObjectTypes>
	<dependencies>
		<executableTestSuite ref="EID61070ae8-13cb-4303-a340-72c8b877b00a"/>
	</dependencies>
	<testModules>
		<TestModule id="EID8944a9ef-bf4e-49c4-9a93-4be27b71a77b">
			<label>IGNORE</label>
			<description>IGNORE</description>
			<parent ref="EIDacc5931c-4ff0-499f-b916-3cda1603456b"/>
			<testCases>
  				<TestCase id="EID89897f44-87d9-4f8e-be29-19e62b0380be">
					<label>Higher Hierarchy Consistency</label>
					<description>Verify that administrative units, except those corresponding to the country level unit representing a Member State or being a co-administered unit, refer to exactly one administrative unit at a higher level of administrative hierarchy.</description>
					<parent ref="EID8944a9ef-bf4e-49c4-9a93-4be27b71a77b"/>
					<testSteps>
						<TestStep id="EIDbead9324-b7b6-405e-bbe8-c59683bfcea1">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID89897f44-87d9-4f8e-be29-19e62b0380be"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EID6a701811-e80f-4c94-876b-c15a23bcb063">
									<label>au-dc.a.1: Each administrative unit refers to exactly one administrative unit at a higher level except those corresponding to the country level unit representing a Member State or being a co-administered unit.</label>
									<description><![CDATA[Verify for each administrative unit, expect those corresponding to the Country Level unit representing a Member State or being a co-administered unit, that it refers to exactly one administrative unit at a higher level of administrative hierarchy, i.e. there is only one administrative unit spatial object at the UpperLevelUnit association role of the administrative Unit.<br/><br/>
Relevant requirements:
<ul>
<li>IR Requirement Annex II Section 8.7.1 (1): Theme-specific Requirements. Each instance of spatial object type AdministrativeUnit, except for the country level unit representing a MemberState and co-administered units, shall refer exactly to one unit at a higher level of administrative hierarchy. This correspondence shall be expressed by the upperLevelUnit association role of AdministrativeUnit spatial object type.</li>
</ul>
Source: <a href="http://inspire.ec.europa.eu/id/ats/data-au/3.1/au-dc/higher-hierarchy" target="_blank">Abstract Test Case 'Higher Hierarchy'</a>, <a href="http://inspire.ec.europa.eu/documents/Data_Specifications/INSPIRE_DataSpecification_AU_v3.1.pdf">INSPIRE Data Specification on Administrative Units, A.3.5</a>]]></description>
									<parent ref="EIDbead9324-b7b6-405e-bbe8-c59683bfcea1"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $featuresWithErrors := $features[self::*:AdministrativeUnit and not(au3:nationalLevel[1]/text()='1stOrder' or au:nationalLevel[1]/@xlink:href='http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/1stOrder' or *:administeredBy/@xlink:href) and count(*:upperLevelUnit[@xlink:href or @xsi:nil='true']) ne 1][position() le $limitErrors]
return
(if ($featuresWithErrors) then 'FAILED' else 'PASSED', 
 local:error-statistics('TR.featuresWithErrors', count($featuresWithErrors)),
 for $feature in $featuresWithErrors
   order by $feature/@gml:id
	let $level := $feature/au3:nationalLevel[1]/text() | $feature/au:nationalLevel[1]/@xlink:href
   return local:addMessage('TR.noUpperLevelArea', map { 'filename': local:filename($feature), 'featureType': local-name($feature), 'gmlid': string($feature/@gml:id), 'level': substring-after(data($level),'http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/') })) 
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.featuresWithErrors"/>
										<translationTemplate ref="TR.noUpperLevelArea"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>
  				<TestCase id="EID9a78ce54-e8b5-4484-b73c-ce11f822391a">
					<label>Lower Hierarchy Consistency</label>
					<description>Verify that administrative units, except those corresponding to the lowest level, refer to its respective lower level units in the administrative hierarchy.</description>
					<parent ref="EID8944a9ef-bf4e-49c4-9a93-4be27b71a77b"/>
					<testSteps>
						<TestStep id="EIDd7a07c8f-02ec-4477-891b-e9fad70a06e7">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID9a78ce54-e8b5-4484-b73c-ce11f822391a"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EIDca5200cc-d6e1-47d6-837d-8b1dc40d30fd">
									<label>au-dc.b.1: Each administrative unit refers to a lower level administrative unit, except those corresponding to the lowest level of the administrative hierarchy.</label>
									<description><![CDATA[Verify for each administrative unit, expect those corresponding to the lowest level of the administrative hierarchy, that it refers to a lower level administrative unit using the lowerLevelUnit association role.<br/><br/>
Relevant requirements:
<ul>
<li>IR Requirement Annex II Section 4.4 (2)): Theme-specific Requirements. Each instance of spatial object type AdministrativeUnit, except for those at the lowest level, shall refer to their respective lower level units. This correspondence shall be expressed by the lowerLevelUnit association role of AdministrativeUnit spatial object type.</li>
</ul>
Source: <a href="http://inspire.ec.europa.eu/id/ats/data-au/3.1/au-dc/lower-hierarchy" target="_blank">Abstract Test Case 'Lower Hierarchy'</a>, <a href="http://inspire.ec.europa.eu/documents/Data_Specifications/INSPIRE_DataSpecification_AU_v3.1.pdf">INSPIRE Data Specification on Administrative Units, A.3.6</a>]]></description>
									<parent ref="EIDd7a07c8f-02ec-4477-891b-e9fad70a06e7"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $levels := if ($features[self::*:AdministrativeUnit and (au3:nationalLevel[1]/text()='6thOrder' or au:nationalLevel[1]/@xlink:href='http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/6thOrder')]) then ('1stOrder','2ndOrder','3rdOrder','4thOrder','5thOrder')
                    else if ($features[self::*:AdministrativeUnit and (au3:nationalLevel[1]/text()='5thOrder' or au:nationalLevel[1]/@xlink:href='http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/5thOrder')]) then ('1stOrder','2ndOrder','3rdOrder','4thOrder')
                    else if ($features[self::*:AdministrativeUnit and (au3:nationalLevel[1]/text()='4thOrder' or au:nationalLevel[1]/@xlink:href='http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/4thOrder')]) then ('1stOrder','2ndOrder','3rdOrder')
                    else if ($features[self::*:AdministrativeUnit and (au3:nationalLevel[1]/text()='3rdOrder' or au:nationalLevel[1]/@xlink:href='http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/3rdOrder')]) then ('1stOrder','2ndOrder')
                    else if ($features[self::*:AdministrativeUnit and (au3:nationalLevel[1]/text()='2ndOrder' or au:nationalLevel[1]/@xlink:href='http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/2ndOrder')]) then '1stOrder'
                    else ()
return                    
if (count($levels)=0) then 'PASSED'
else
let $featuresWithErrors := $features[self::*:AdministrativeUnit and (au3:nationalLevel[1]/text()=$levels or substring-after(au:nationalLevel[1]/@xlink:href,'http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/')=$levels) and not(*:lowerLevelUnit[@xlink:href or @xsi:nil='true'])][position() le $limitErrors]
return
(if ($featuresWithErrors) then 'FAILED' else 'PASSED', 
 local:error-statistics('TR.featuresWithErrors', count($featuresWithErrors)),
 for $feature in $featuresWithErrors
   order by $feature/@gml:id
	let $level := $feature/au3:nationalLevel[1]/text() | $feature/au:nationalLevel[1]/@xlink:href
   return local:addMessage('TR.incorrectLowerLevelArea', map { 'filename': local:filename($feature), 'featureType': local-name($feature), 'gmlid': string($feature/@gml:id), 'level': substring-after(data($level),'http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/') })) 
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.featuresWithErrors"/>
										<translationTemplate ref="TR.incorrectLowerLevelArea"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID13980d13-1916-4c1b-a8ad-2ab4c804c477">
									<label>au-dc.b.2: Each administrative unit refers to lower level administrative units on the next level, except those corresponding to the lowest level of the administrative hierarchy.</label>
									<description><![CDATA[Verify for each administrative unit, expect those corresponding to the lowest level of the administrative hierarchy, that it refers to administrative units on the next level using the lowerLevelUnit association role.<br/><br/>
Relevant requirements:
<ul>
<li>IR Requirement Annex II Section 4.4 (2)): Theme-specific Requirements. Each instance of spatial object type AdministrativeUnit, except for those at the lowest level, shall refer to their respective lower level units. This correspondence shall be expressed by the lowerLevelUnit association role of AdministrativeUnit spatial object type.</li>
</ul>
Source: <a href="http://inspire.ec.europa.eu/id/ats/data-au/3.1/au-dc/lower-hierarchy" target="_blank">Abstract Test Case 'Lower Hierarchy'</a>, <a href="http://inspire.ec.europa.eu/documents/Data_Specifications/INSPIRE_DataSpecification_AU_v3.1.pdf">INSPIRE Data Specification on Administrative Units, A.3.6</a>]]></description>
									<parent ref="EIDd7a07c8f-02ec-4477-891b-e9fad70a06e7"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $levels := if ($features[self::*:AdministrativeUnit and (au3:nationalLevel[1]/text()='6thOrder' or au:nationalLevel[1]/@xlink:href='http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/6thOrder')]) then ('1stOrder','2ndOrder','3rdOrder','4thOrder','5thOrder')
                    else if ($features[self::*:AdministrativeUnit and (au3:nationalLevel[1]/text()='5thOrder' or au:nationalLevel[1]/@xlink:href='http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/5thOrder')]) then ('1stOrder','2ndOrder','3rdOrder','4thOrder')
                    else if ($features[self::*:AdministrativeUnit and (au3:nationalLevel[1]/text()='4thOrder' or au:nationalLevel[1]/@xlink:href='http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/4thOrder')]) then ('1stOrder','2ndOrder','3rdOrder')
                    else if ($features[self::*:AdministrativeUnit and (au3:nationalLevel[1]/text()='3rdOrder' or au:nationalLevel[1]/@xlink:href='http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/3rdOrder')]) then ('1stOrder','2ndOrder')
                    else if ($features[self::*:AdministrativeUnit and (au3:nationalLevel[1]/text()='2ndOrder' or au:nationalLevel[1]/@xlink:href='http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/2ndOrder')]) then '1stOrder'
                    else ()
return                    
if (count($levels)=0) then 'PASSED'
else
let $candidates := $features[self::*:AdministrativeUnit and (au3:nationalLevel[1]/text()=$levels or substring-after(au:nationalLevel[1]/@xlink:href,'http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/')=$levels)]
let $refcount := count($candidates/*:lowerLevelUnit[not(@xsi:nil='true')]/@xlink:href)
let $dummy := if ($refcount>100) then local:log("Checking " || $refcount || " feature references - this may take awhile...") else ()
let $messages := 
  (for $candidate in $candidates
   order by $candidate/@gml:id
  let $level := if ($candidate[au3:nationalLevel[1]/text()='5thOrder' or au:nationalLevel[1]/@xlink:href='http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/5thOrder']) then '6thOrder'
                else if ($candidate[au3:nationalLevel[1]/text()='4thOrder' or au:nationalLevel[1]/@xlink:href='http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/4thOrder']) then ('5thOrder', '6thOrder')
                else if ($candidate[au3:nationalLevel[1]/text()='3rdOrder' or au:nationalLevel[1]/@xlink:href='http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/3rdOrder']) then ('4thOrder', '5thOrder', '6thOrder')
					 else if ($candidate[au3:nationalLevel[1]/text()='2ndOrder' or au:nationalLevel[1]/@xlink:href='http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/2ndOrder']) then ('3rdOrder', '4thOrder', '5thOrder', '6thOrder')
                else if ($candidate[au3:nationalLevel[1]/text()='1stOrder' or au:nationalLevel[1]/@xlink:href='http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/1stOrder']) then ('2ndOrder', '3rdOrder', '4thOrder', '5thOrder', '6thOrder')
                else ()
  return
  for $href in $candidate/*:lowerLevelUnit[not(@xsi:nil='true')]/@xlink:href 
    let $element := local:return-reference($href)
    return
    if (not($element)) then () (: ignore unresolvable links here, this is handled by the information accessibility tests :)
    else if (not($element[self::*:AdministrativeUnit])) then local:addMessage('TR.unknownXMLResource2', map { 'filename': local:filename($candidate), 'featureType': local-name($candidate), 'gmlid': string($candidate/@gml:id), 'url': string($href), 'elementNameExpected': 'AdministrativeUnit', 'elementName': local-name($element), 'namespace': namespace-uri($element) })
    else if (not($element/au3:nationalLevel[1]/text()=$level or substring-after($element/au:nationalLevel[1]/@xlink:href,'http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/')=$level)) then local:addMessage('TR.notAnAdminUnitAtNextLevel', map { 'filename': local:filename($candidate), 'featureType': local-name($candidate), 'gmlid': string($candidate/@gml:id), 'url': string($href), 'expectedLevel': $level, 'level': substring-after($element/au3:nationalLevel[1]/text() | $element/au:nationalLevel[1]/@xlink:href,'http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/') })
    else ())[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count(fn:distinct-values($messages//etf:argument[@token='gmlid']/text()))),
 $messages)									
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.featuresWithErrors"/>
										<translationTemplate ref="TR.notAnAdminUnitAtNextLevel"/>
										<translationTemplate ref="TR.urlNotHttp2"/>
										<translationTemplate ref="TR.idNotFound2"/>
										<translationTemplate ref="TR.resourceNotAccessibleException2"/>
										<translationTemplate ref="TR.resourceNotAccessible2"/>
										<translationTemplate ref="TR.unknownXMLResource2"/>
										<translationTemplate ref="TR.unknownResourceType2"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>
   				<TestCase id="EID8575dc23-994f-439b-b896-1e298845ea87">
					<label>Co-administered</label>
					<description>Verify whether the adminsteredBy association role is used for administrative units co-administered by two or more administrative units, and the units co-administering this unit apply the inverse role coAdminister.</description>
					<parent ref="EID8944a9ef-bf4e-49c4-9a93-4be27b71a77b"/>
					<testSteps>
						<TestStep id="EIDe60579bd-1e10-4957-b27c-d45fe0cd8c43">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID8575dc23-994f-439b-b896-1e298845ea87"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EID84911bd1-f553-444b-ab96-818ed7e9d956">
									<label>au-dc.c.1: Each administrative unit co-administered by two or more administrative units uses the association role administeredBy, and the units co-administering this unit use the inverse role coAdminister.</label>
									<description><![CDATA[For each administrative unit co-administered by two or more other administrative units, verify that:
* it refers to these co-administrative units by using the administeredBy association role.
* each of these co-administrative units refers to the mentioned co-administered unit by using the coAdminister association role.<br/><br/>
Relevant requirements:
<ul>
<li>IR Requirement Annex II Section 4.4 (3)): Theme-specific Requirements. If an administrative unit is co-administered by two or more other administrative units the association role administeredBy shall be used. The units co-administering this unit shall apply inverse role coAdminister.</li>
</ul>
Source: <a href="http://inspire.ec.europa.eu/id/ats/data-au/3.1/au-dc/co-administered" target="_blank">Abstract Test Case 'Co-administered'</a>, <a href="http://inspire.ec.europa.eu/documents/Data_Specifications/INSPIRE_DataSpecification_AU_v3.1.pdf">INSPIRE Data Specification on Administrative Units, A.3.7</a>]]></description>
									<parent ref="EIDe60579bd-1e10-4957-b27c-d45fe0cd8c43"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $candidates := $features[self::*:AdministrativeUnit and count(*:administeredBy[not(@xsi:nil='true') and @xlink:href]) ge 2]
let $refcount := count($candidates/*:administeredBy[not(@xsi:nil='true')]/@xlink:href)
let $dummy := if ($refcount>100) then local:log("Checking " || $refcount || " feature references - this may take awhile...") else ()
let $messages :=
  (for $href in $candidates/*:administeredBy[not(@xsi:nil='true')]/@xlink:href 
    let $candidate := $href/../..
    let $element := local:return-reference($href)
    order by $candidate/@gml:id
    return
    if (not($element)) then () (: ignore unresolvable links here, this is handled by the information accessibility tests :)
    else if (not($element[self::*:AdministrativeUnit])) then local:addMessage('TR.unknownXMLResource2', map { 'filename': local:filename($candidate), 'featureType': local-name($candidate), 'gmlid': string($candidate/@gml:id), 'url': string($href), 'elementNameExpected': 'AdministrativeUnit', 'elementName': local-name($element), 'namespace': namespace-uri($element) })
    else 
      let $backref :=
      for $href2 in $element/*:coAdminister[not(@xsi:nil='true')]/@xlink:href
        let $element2 := local:return-reference($href2)
        return
        if (not($element2)) then $href2 (: ignore unresolvable links here, this is handled by the information accessibility tests :)
        else if ($candidate/@gml:id ne $element2/@gml:id) then ()
        else $href2
      return
      if ($backref) then ()
      else local:addMessage('TR.incorrectCoAdministered', map { 'filename': local:filename($candidate), 'featureType' : 'AdministrativeUnit', 'gmlid': string($candidate/@gml:id), 'url': string($href) }))[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count(fn:distinct-values($messages//etf:argument[@token='gmlid']/text()))),
 $messages)
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.featuresWithErrors"/>
										<translationTemplate ref="TR.incorrectCoAdministered"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>
   				<TestCase id="EID430577bd-bcb1-4f94-8ec0-8aed8795d1c5">
					<label>Condominium administration</label>
					<description>Verify whether each condominium is only administered by administrative units at country level.</description>
					<parent ref="EID8944a9ef-bf4e-49c4-9a93-4be27b71a77b"/>
					<testSteps>
						<TestStep id="EIDccc9f79a-f082-4164-8beb-cfab6e34254d">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID430577bd-bcb1-4f94-8ec0-8aed8795d1c5"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EID87e1aeaf-5c2f-4c53-bfd7-410bfaace32b">
									<label>au-dc.d.1: Each condominium is only administered by administrative units at country level.</label>
									<description><![CDATA[Verify that each condominium only refers to administrative units at country level (each of them representing a Member State) through using the admUnit association role of the condominium spatial object type.<br/><br/>
Relevant requirements:
<ul>
<li>IR Requirement Annex II Section 4.4 (7): Theme-specific Requirements. Condominiums can only be administered by administrative units at country level.</li>
</ul>
Source: <a href="http://inspire.ec.europa.eu/id/ats/data-au/3.1/au-dc/condominiumAdministration" target="_blank">Abstract Test Case 'Condominium administration'</a>, <a href="http://inspire.ec.europa.eu/documents/Data_Specifications/INSPIRE_DataSpecification_AU_v3.1.pdf">INSPIRE Data Specification on Administrative Units, A.3.11</a>]]></description>
									<parent ref="EIDccc9f79a-f082-4164-8beb-cfab6e34254d"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $candidates := $features[self::*:Condominium]
let $refcount := count($candidates/*:admUnit[not(@xsi:nil='true')]/@xlink:href)
let $dummy := if ($refcount>100) then local:log("Checking " || $refcount || " feature references - this may take awhile...") else ()
let $messages :=
  (for $href in $candidates/*:admUnit[not(@xsi:nil='true')]/@xlink:href 
    let $candidate := $href/../..
    let $element := local:return-reference($href)
    order by $candidate/@gml:id
    return
    if (not($element)) then () (: ignore unresolvable links here, this is handled by the information accessibility tests :)
    else if (not($element[self::*:AdministrativeUnit])) then local:addMessage('TR.unknownXMLResource2', map { 'filename': local:filename($candidate), 'featureType': local-name($candidate), 'gmlid': string($candidate/@gml:id), 'url': string($href), 'elementNameExpected': 'AdministrativeUnit', 'elementName': local-name($element), 'namespace': namespace-uri($element) })
    else if ($element[au3:nationalLevel[1]/text()='1stOrder' or au:nationalLevel[1]/@xlink:href='http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/1stOrder']) then ()
    else local:addMessage('TR.incorrectCondominiumAdministration', map { 'filename': local:filename($candidate), 'featureType' : local-name($candidate), 'gmlid': string($candidate/@gml:id), 'url' : string($href), 'level': substring-after($element/au3:nationalLevel[1]/text() | $element/au:nationalLevel[1]/@xlink:href,'http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/') }))[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count(fn:distinct-values($messages//etf:argument[@token='gmlid']/text()))),
 $messages)									
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.featuresWithErrors"/>
										<translationTemplate ref="TR.incorrectCondominiumAdministration"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase> 
				<TestCase id="EID26ea8352-0519-4b9c-9454-89bfc4d13f51">
					<label>Area</label>
					<description>Verify whether administrative units having the same level of administrative hierarchy do not conceptually share common areas.</description>
					<parent ref="EID8944a9ef-bf4e-49c4-9a93-4be27b71a77b"/>
					<testSteps>
						<TestStep id="EIDdb19eabc-cb96-4fa7-bcf0-aea9385423f0">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID26ea8352-0519-4b9c-9454-89bfc4d13f51"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EID78d41633-eedf-4a06-99fb-753a2d88043e">
									<label>au-dc.e.1: Administrative units having the same level of administrative hierarchy do not conceptually share common areas.</label>
									<description><![CDATA[Verify that the geometry of each administrative unit does not overlap with the geometries of other administrative units having the same level of administrative hierarchy as the examined one.<br/><br/>
Relevant requirements:
<ul>
<li>IR Requirement Annex II Section 4.4 (4): Theme-specific Requirements. Administrative units at the same level of administrative hierarchy shall not conceptually share common areas.</li>
</ul>
Source: <a href="http://inspire.ec.europa.eu/id/ats/data-au/3.1/au-dc/area" target="_blank">Abstract Test Case 'Area'</a>, <a href="http://inspire.ec.europa.eu/documents/Data_Specifications/INSPIRE_DataSpecification_AU_v3.1.pdf">INSPIRE Data Specification on Administrative Units, A.3.8</a>]]></description>
									<parent ref="EIDdb19eabc-cb96-4fa7-bcf0-aea9385423f0"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $messages :=
(for $candidate in $features[self::*:AdministrativeUnit]
 return
 try {
  let $level := substring-after(data($candidate/au3:nationalLevel[1]/text() | $candidate/au:nationalLevel[1]/@xlink:href),'http://inspire.ec.europa.eu/codelist/AdministrativeHierarchyLevel/')
  let $candidate_geometry := ggeo:getGeometry($candidate/@gml:id,$candidate/*:geometry/*[1])
  let $env := ggeo:envelope($candidate_geometry)
  let $other_features := ggeo:search($env[1],$env[2],$env[3],$env[4])
  for $feature in $other_features[self::*:AdministrativeUnit and (au:nationalLevel/@xlink:href = $candidate/au:nationalLevel/@xlink:href or au3:nationalLevel/text() = $candidate/au3:nationalLevel/text()) and not (@gml:id = $candidate/@gml:id)]
   order by $candidate/@gml:id, $feature/@gml:id
   return
   try {
   let $other_geometry := ggeo:getGeometry($feature/@gml:id,$feature/*:geometry/*[1])
   let $check := ggeo:relate($candidate_geometry, $other_geometry, 'F********') 
	return 
	if ($check) then () 
	else 
	let $intersection := string(ggeo:intersection($candidate_geometry, $other_geometry))
	let $polygons := functx:get-matches($intersection,'POLYGON\s?\(\s?\([\d,\.\s]+\)\s?\)')[fn:string-length(.)>0]
	return local:addMessage('TR.AdministrativeUnitArea', map { 'filename': local:filename($candidate), 'featureType' : local-name($candidate), 'gmlid': string($candidate/@gml:id), 'gmlid2': string($feature/@gml:id), 'level': $level, 'sharedArea': fn:string-join($polygons, ', ') })
	} catch * { 
		let $dummy := local:log('Processing feature ' || string($feature/@gml:id) || '. Exception: ' || $err:code || ' - ' || $err:description || ' [' || $err:module || ', line: ' || $err:line-number || ', column: ' || $err:column-number || ']')
		return () (: silently record the exception in the log, but do not raise errors in the test report as parsing exceptions are already reported in assertion gmlas.d.11 :)
	}
 } catch * { 
	let $dummy := local:log('Processing feature ' || string($candidate/@gml:id) || '. Exception: ' || $err:code || ' - ' || $err:description || ' [' || $err:module || ', line: ' || $err:line-number || ', column: ' || $err:column-number || ']')
	return () (: silently record the exception in the log, but do not raise errors in the test report as parsing exceptions are already reported in assertion gmlas.d.11 :)
 }
)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count(fn:distinct-values($messages//etf:argument[@token='gmlid']/text()))),
 $messages)									
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.featuresWithErrors"/>
										<translationTemplate ref="TR.AdministrativeUnitArea"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>
				<TestCase id="EID3bfa3fa6-d22a-4f2d-91b1-d83b16b8c088">
					<label>Boundary</label>
					<description>Verify whether all instances of the spatial object type administrative boundary correspond to the edges in the topological structure of the complete (including all levels) boundary graph.</description>
					<parent ref="EID8944a9ef-bf4e-49c4-9a93-4be27b71a77b"/>
					<testSteps>
						<TestStep id="EIDeea3c33d-0bbe-4de6-ad29-ad677b930609">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID3bfa3fa6-d22a-4f2d-91b1-d83b16b8c088"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EIDe5ef134b-36f4-4140-8d67-e8be997cd892">
									<label>au-dc.f.1: The geometry of each instance administrative boundary corresponds to an edge in the topological structure formed by the complete boundary graph, including the boundaries of all levels.</label>
									<description><![CDATA[Inspect that the geometry of each instance administrative boundary correspond to an edge in the topological structure formed by the complete boundary graph, including the boundaries of all levels.<br/><br/>
Relevant requirements:
<ul>
<li>IR Requirement Annex II Section 4.4 (5): Theme-specific Requirements. Instances of the spatial object type AdministrativeBoundary shall correspond to the edges in the topological structure of the complete (including all levels) boundary graph.</li>
</ul>
Source: <a href="http://inspire.ec.europa.eu/id/ats/data-au/3.1/au-dc/boundary" target="_blank">Abstract Test Case 'Boundary'</a>, <a href="http://inspire.ec.europa.eu/documents/Data_Specifications/INSPIRE_DataSpecification_AU_v3.1.pdf">INSPIRE Data Specification on Administrative Units, A.3.9</a>]]></description>
									<parent ref="EIDeea3c33d-0bbe-4de6-ad29-ad677b930609"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $messages :=
(for $candidate in $features[self::*:AdministrativeBoundary]
 return
 try {
  let $candidate_geometry := ggeo:getGeometry($candidate/@gml:id,$candidate/*:geometry/*[1])
  let $env := ggeo:envelope($candidate_geometry)
  let $other_features := ggeo:search($env[1],$env[2],$env[3],$env[4])
  let $onBoundary :=
  for $feature in $other_features[self::*:AdministrativeUnit]
  return
  try {
   let $other_geometry := ggeo:getGeometry($feature/@gml:id,$feature/*:geometry/*[1])
   let $check := ggeo:relate($candidate_geometry, $other_geometry, 'FTFF*FT*T') 
	return if ($check) then $feature else ()
  } catch * { 
		let $dummy := local:log('Processing feature ' || string($feature/@gml:id) || '. Exception: ' || $err:code || ' - ' || $err:description || ' [' || $err:module || ', line: ' || $err:line-number || ', column: ' || $err:column-number || ']')
		return () (: silently record the exception in the log, but do not raise errors in the test report as parsing exceptions are already reported in assertion gmlas.d.11 :)
  }
  return 
  if ($onBoundary) then () 
  else local:addMessage('TR.AdministrativeBoundaryOnUnit', map { 'filename': local:filename($candidate), 'featureType' : local-name($candidate), 'gmlid': string($candidate/@gml:id) })
 } catch * { 
	let $dummy := local:log('Processing feature ' || string($candidate/@gml:id) || '. Exception: ' || $err:code || ' - ' || $err:description || ' [' || $err:module || ', line: ' || $err:line-number || ', column: ' || $err:column-number || ']')
	return () (: silently record the exception in the log, but do not raise errors in the test report as parsing exceptions are already reported in assertion gmlas.d.11 :)
 }
)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count(fn:distinct-values($messages//etf:argument[@token='gmlid']/text()))),
 $messages)									
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.featuresWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>	
				<TestCase id="EID374ce52a-dcfb-4f75-836d-c7ba1b551c55">
					<label>Condominium spatial extent</label>
					<description>Verify whether the spatial extent of a condominium is not part of the geometry representing the spatial extent of an administrative unit.</description>
					<parent ref="EID8944a9ef-bf4e-49c4-9a93-4be27b71a77b"/>
					<testSteps>
						<TestStep id="EID92ac87b5-cd0e-4e40-a990-ffe39328d633">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID374ce52a-dcfb-4f75-836d-c7ba1b551c55"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EIDcd01b1b4-cec2-434a-b4c0-84f264d6b7c3">
									<label>au-dc.g.1: The spatial extent of a condominium is not part of the geometry representing the spatial extent of an administrative unit.</label>
									<description><![CDATA[Inspect each condominium and verify that its geometry does not overlap with the geometry of any of the administrative units in the same data set.<br/><br/>
Relevant requirements:
<ul>
<li>IR Requirement Annex II Section 4.4 (6): Theme-specific Requirements. The spatial extent of a condominium may not be part of the geometry representing the spatial extent of an administrative unit.</li>
</ul>
Source: <a href="http://inspire.ec.europa.eu/id/ats/data-au/3.1/au-dc/condominiumSpatialExtent" target="_blank">Abstract Test Case 'Condominium Spatial Extent'</a>, <a href="http://inspire.ec.europa.eu/documents/Data_Specifications/INSPIRE_DataSpecification_AU_v3.1.pdf">INSPIRE Data Specification on Administrative Units, A.3.10</a>]]></description>
									<parent ref="EID92ac87b5-cd0e-4e40-a990-ffe39328d633"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $messages :=
(for $candidate in $features[self::*:Condominium]
 return
 try {
  let $candidate_geometry := ggeo:getGeometry($candidate/@gml:id,$candidate/*:geometry/*[1])
  let $env := ggeo:envelope($candidate_geometry)
  let $other_features := ggeo:search($env[1],$env[2],$env[3],$env[4])
  for $feature in $other_features[self::*:AdministrativeUnit]
  order by $candidate/@gml:id, $feature/@gml:id
  return
  try {
   let $other_geometry := ggeo:getGeometry($feature/@gml:id,$feature/*:geometry/*[1])
   let $check := ggeo:relate($candidate_geometry, $other_geometry, 'F********') 
	return 
	if ($check) then () 
	else 
	let $intersection := string(ggeo:intersection($candidate_geometry, $other_geometry))
   let $polygons := functx:get-matches($intersection,'POLYGON\s?\(\s?\([\d,\.\s]+\)\s?\)')[fn:string-length(.)>0]
   return local:addMessage('TR.wrongSpatialCondominiumExtent', map { 'filename': local:filename($candidate), 'featureType' : local-name($candidate), 'gmlid': string($candidate/@gml:id), 'gmlid2': string($feature/@gml:id), 'sharedArea': fn:string-join($polygons, ', ') })
  } catch * { 
		let $dummy := local:log('Processing feature ' || string($feature/@gml:id) || '. Exception: ' || $err:code || ' - ' || $err:description || ' [' || $err:module || ', line: ' || $err:line-number || ', column: ' || $err:column-number || ']')
		return () (: silently record the exception in the log, but do not raise errors in the test report as parsing exceptions are already reported in assertion gmlas.d.11 :)
  } 
 } catch * { 
	let $dummy := local:log('Processing feature ' || string($candidate/@gml:id) || '. Exception: ' || $err:code || ' - ' || $err:description || ' [' || $err:module || ', line: ' || $err:line-number || ', column: ' || $err:column-number || ']')
	return () (: silently record the exception in the log, but do not raise errors in the test report as parsing exceptions are already reported in assertion gmlas.d.11 :)
 }
)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.featuresWithErrors', count(fn:distinct-values($messages//etf:argument[@token='gmlid']/text()))),
 $messages)									
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.featuresWithErrors"/>
										<translationTemplate ref="TR.wrongSpatialCondominiumExtent"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>					
			</testCases>
		</TestModule>
	</testModules>
</ExecutableTestSuite>
