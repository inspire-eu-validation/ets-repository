<?xml version="1.0" encoding="utf-8"?>
<ExecutableTestSuite xmlns="http://www.interactive-instruments.de/etf/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" id="EIDec7323d5-d8f0-4cfe-b23a-b826df86d58c" xsi:schemaLocation="http://www.interactive-instruments.de/etf/2.0 https://resources.etf-validator.net/schema/v2/val/ignoreRef.xsd">
	<itemHash>bQ==</itemHash>
	<remoteResource>https://github.com/inspire-eu-validation/ets-repository/tree/master/metadata/iso</remoteResource>
	<localPath>/auto</localPath>
	<label>Conformance class: INSPIRE Profile based on EN ISO 19115 and EN ISO 19119</label>
	<description><![CDATA[This test suite examines metadata records against the requirements for metadata in INSPIRE.<br/><br/>
Please report any issues or problems <a href="https://github.com/inspire-eu-validation/community/wiki/Your-feedback" target="_blank">in GitHub</a>.<br/><br/>
Known limitations are documented in the description of the applicable test case or test assertion.<br/><br/>
There is a general limitation in all assertions that polymorphism and containment by reference (see the <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/README#ref_TG_MD" target="_blank">Technical Guidance</a>, sub-clauses A.3, A.4 and A.5) are not supported. However, the current Abstract Test Suite does not support polymorphism and references either (all XPath expressions do not support polymorhism or references; in addition, schema validation is only executed against the ISO/OGC schemas without extensions). It is therefore unclear if this is really a limitation or if the sections in the technical guidance are outdated.<br/><br/>
Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119" target="_blank">Conformance Class 'INSPIRE Profile based on EN ISO 19115 and EN ISO 19119'</a><br/><br/>
Pre-requisite conformance classes:
<ul><li><a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/xml-encoding" target="_blank">Conformance Class 'XML encoding of ISO 19115/19119 metadata'</a></li></ul>]]></description>
	<reference>../../../inspire-md-bsxets.xq</reference>
	<version>1.0.0</version>
	<author>interactive instruments GmbH</author>
	<creationDate>2016-08-30T00:00:00Z</creationDate>
	<lastEditor>interactive instruments GmbH</lastEditor>
	<lastUpdateDate>2019-11-12T11:44:00Z</lastUpdateDate>
	<tags>
		<tag ref="EID3b9846c7-3940-4795-ae1d-0b5d82375c76"/>
	</tags>
	<testDriver ref="EID4dddc9e2-1b21-40b7-af70-6a2d156ad130"/>
	<translationTemplateBundle ref="EID70a263c0-0ad7-42f2-9d4d-0d8a4ca71b52"/>
	<ParameterList name="ETF Standard Parameters for metadata XML test objects">
		<!-- TODO clean up, currently disabled due to open issues with schema validation
		<parameter name="encoding" required="false">
			<defaultValue>CSW ISO AP 1.0.0</defaultValue>
			<description ref="TR.metadataEncoding"/>
			<allowedValues>^(CSW ISO AP 1\.0\.0|ISO/TS 19139)$</allowedValues>
			<type>string</type>
		</parameter>
		<parameter name="Schema_file" required="false">
			<description ref="TR.metadataSchema"/>
			<allowedValues>^(apiso\.xsd|gmd\.xsd|apiso-csw\.xsd|gmd-csw\.xsd)?$</allowedValues>
			<type>string</type>
		</parameter>
		-->
		<parameter name="files_to_test" required="true">
			<defaultValue>.*</defaultValue>
			<description ref="TR.filesToTest"/>
			<allowedValues>.*</allowedValues>
			<type>string</type>
		</parameter>
		<parameter name="tests_to_execute" required="false">
			<defaultValue>.*</defaultValue>
			<description ref="TR.testsToExecute"/>
			<allowedValues>.*</allowedValues>
			<type>string</type>
		</parameter>
	</ParameterList>
	<supportedTestObjectTypes>
		<testObjectType ref="EID5a60dded-0cb0-4977-9b06-16c6c2321d2e"/>
	</supportedTestObjectTypes>
	<dependencies>
		<executableTestSuite ref="EIDe3500038-e37c-4dcf-806c-6bc82d585b3b"/>
	</dependencies>
	<testModules>
		<TestModule id="EID4c5d8006-3ac6-43d9-a1a3-1e19bf163ff3">
			<label>IGNORE</label>
			<description>IGNORE</description>
			<parent ref="EIDec7323d5-d8f0-4cfe-b23a-b826df86d58c"/>
			<testCases>
				<TestCase id="EID31c568d6-1073-4ff5-a5b2-f0e6b9683177">
					<label>Common tests</label>
					<description>Execute tests that apply for all metadata records.</description>
					<parent ref="EID4c5d8006-3ac6-43d9-a1a3-1e19bf163ff3"/>
					<testSteps>
						<TestStep id="EID95a1a8a8-3132-453f-921a-c0334781e8bb">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID31c568d6-1073-4ff5-a5b2-f0e6b9683177"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EIDdcb6ea6f-08ee-45cf-a947-ae411ec5bc81">
									<label>md-iso.a.1: Title</label>
									<description><![CDATA[<p>Checks if a title is present and not an empty characterstring.<br/><br/>
The title is a characteristic, and often unique, name by which the resource is known. The title is the most informative element of a metadata record and usually the highest priority as search engines go to this element.</p>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/title" target="_blank">Abstract Test Case 'Title'</a></p>]]></description>
									<parent ref="EID95a1a8a8-3132-453f-921a-c0334781e8bb"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $messages :=
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $title := $record/gmd:identificationInfo[1]/*/gmd:citation/*/gmd:title/*[1]
	 return
	 if (not($title)) then
		local:addMessage('TR.noTitle', map { 'filename': local:filename($record), 'id': $rid })
	 else if (string-length(normalize-space($title/text())) = 0) then
		local:addMessage('TR.emptyTitle', map { 'filename': local:filename($record), 'id': $rid })
	 else ()
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noTitle"/>
										<translationTemplate ref="TR.emptyTitle"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EIDb0de8830-67ee-4bc5-b122-136060ea6103">
									<label>md-iso.a.2: Abstract</label>
									<description><![CDATA[<p>Checks if an abstract is present and not an empty characterstring.<br/><br/>
The abstract is a brief narrative summary of the content of the resource and provides a clear and concise statement that enables the reader to understand the content of the data or service.</p>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/abstract" target="_blank">Abstract Test Case 'Abstract'</a></p>]]></description>
									<parent ref="EID95a1a8a8-3132-453f-921a-c0334781e8bb"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $messages :=
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $abstract := $record/gmd:identificationInfo[1]/*/gmd:abstract/*[1]
	 return
	 if (not($abstract)) then
		local:addMessage('TR.noAbstract', map { 'filename': local:filename($record), 'id': $rid })
	 else if (string-length(normalize-space($abstract/text())) = 0) then
		local:addMessage('TR.emptyAbstract', map { 'filename': local:filename($record), 'id': $rid })
	 else ()
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.recordsWithErrors"/>
										<translationTemplate ref="TR.noAbstract"/>
										<translationTemplate ref="TR.emptyAbstract"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EIDc297017d-05a6-4026-97de-f581bb12a9ad">
									<label>md-iso.a.3: Access and use conditions</label>
									<description><![CDATA[<p>Conditions applying to access and use must be described at least once for the metadata resource.</p>
<p>The test checks if a useLimitation element is provided and it is not an empty characterstring.<br/><br/>
If no conditions apply to the access and use of the resource, "no conditions apply" shall be used.<br/><br/>
If conditions are unknown, "conditions unknown" shall be used.<br/><br/>
Descriptions of terms and conditions, including where applicable, the corresponding fees shall be provided through this element or a link where these terms and conditions are described.<br/><br/>
The basic test to detect missing or empty use limitation information is executed. If this basic check passes, the content needs to be checked manually for correctness.</p>
<p>Relevant requirement(s):</p>
<ul>
<li>TG MD Requirement 33: If no conditions apply to the access and use of the resource, ‘no conditions apply’ shall be used. If conditions are unknown, ‘conditions unknown’ shall be used.</li>
<li>TG MD Requirement 34: Descriptions of terms and conditions, including where applicable, the corresponding fees shall be provided through this element or a link (URL) where these terms and conditions are described.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/ds-access-use" target="_blank">Abstract Test Case 'Dataset access use'</a></p>]]></description>
									<parent ref="EID95a1a8a8-3132-453f-921a-c0334781e8bb"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $messages :=
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $useLimitations := $record/gmd:identificationInfo[1]/*/gmd:resourceConstraints/*/gmd:useLimitation/*[1]
	 return
	 if (not($useLimitations)) then
		local:addMessage('TR.noUseLimitation', map { 'filename': local:filename($record), 'id': $rid })
	 else if (some $useLim in $useLimitations satisfies string-length(normalize-space($useLim/text())) &gt; 0) then ()
	 else
		local:addMessage('TR.emptyUseLimitation', map { 'filename': local:filename($record), 'id': $rid })
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED_MANUAL',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 if ($messages) then $messages
 else
  for $record in $records
	let $rid := $record/gmd:fileIdentifier/*/text()
	let $useLimitations := $record/gmd:identificationInfo[1]/*/gmd:resourceConstraints/*/gmd:useLimitation/*[1]
	 return
	  if (some $useLim in $useLimitations satisfies string-length(normalize-space($useLim/text())) &gt; 0) then
	  local:addMessage('TR.checkUseLimitation', map { 'filename': local:filename($record), 'id': $rid, 'text': string-join($useLimitations, '; ') })
	  else ())
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noUseLimitation"/>
										<translationTemplate ref="TR.emptyUseLimitation"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID50762969-d83c-4360-ae9c-f28300df4f77">
									<label>md-iso.a.4: Public access</label>
									<description><![CDATA[<p>This test checks if at least one of the elements available inside gmd:resourceConstraints passes at least one of the following checks:</p>
<ul>
<li>Check whether it contains an element accessConstraints of type gmd:MD_RestrictionCode[@codeListValue=x], where x is of type MD_RestrictionCode as defined in <a href="http://standards.iso.org/ittf/PubliclyAvailableStandards/ISO_19139_Schemas/resources/codelist/gmxCodelists.xml#MD_RestrictionCode" target="_blank">ISO 19115, chapter B.5.24</a>. If x is &ldquo;otherRestrictions&rdquo; check also whether the element inside gmd:resourceConstraints contains an element otherConstraints of type CharacterString and which is not an empty characterstring.</li>
<li>Check whether it contains an element classification of type gmd:MD_ClassificationCode[@codeListValue=x], where x is of type MD_ClassificationCode as defined in <a href="http://standards.iso.org/ittf/PubliclyAvailableStandards/ISO_19139_Schemas/resources/codelist/gmxCodelists.xml#MD_ClassificationCode" target="_blank">ISO 19115, chapter B.5.11</a>.</li>
</ul>
<p>If none of the elements inside gmd:resourceConstraints passes at least one of the checks, the test fails.<br /><br /> Relevant requirement(s):</p>
<ul>
<li>TG MD Requirement 30: There shall be at least one ISO 19115 metadata element representing a limitation on public access (see 2.9.1) and one ISO 19115 metadata element representing a condition applying to access and use (see 2.9.2) as part of the different instances of MD_Constraints and its subclasses.</li>
<li>TG MD Requirement 31: There shall be at least one instance of MD_Constraints or one of its subclasses (See SC12 in Section 1.2) even if there is no limitation on public access or no specific condition applies to access and use of the resource.</li>
<li>TG MD Requirement 32: Limitations on public access shall be represented by at least one of these metadata elements:
<ul>
<li>MD_LegalConstraints.accessConstraints</li>
<li>MD_LegalConstraints.otherConstraints</li>
<li>MD_SecurityConstraints.classification</li>
</ul>
</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/ds-public-access" target="_blank">Abstract Test Case 'Dataset public access'</a></p>]]></description>
									<parent ref="EID95a1a8a8-3132-453f-921a-c0334781e8bb"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $iso19115_MD_ClassificationCode := ('unclassified','restricted','confidential','secret','topSecret')
let $iso19115_MD_RestrictionCode_without_otherRestrictions := ('copyright','patent','patentPending','trademark','license','intellectualPropertyRights','restricted')
let $messages :=
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $resourceConstraints := $record/gmd:identificationInfo/*/gmd:resourceConstraints/*
	 let $validConstraints :=
		for $resCon in $resourceConstraints
			let $oneValidAccessConstraint :=
				if ($resCon[gmd:accessConstraints/gmd:MD_RestrictionCode/@codeListValue ='otherRestrictions' and string-length(normalize-space(fn:string-join(gmd:otherConstraints/*/text(),', '))) &gt; 0]) then true()
				else if($resCon/gmd:accessConstraints/gmd:MD_RestrictionCode[@codeListValue = $iso19115_MD_RestrictionCode_without_otherRestrictions]) then true()
				else false()
			let $oneValidClassification := boolean($resCon/gmd:classification/gmd:MD_ClassificationCode[@codeListValue = $iso19115_MD_ClassificationCode])
			return
			if ($oneValidAccessConstraint or $oneValidClassification) then $resCon else ()
	 return
	 if ($validConstraints) then ()
	 else local:addMessage('TR.noValidResourceConstraint', map { 'filename': local:filename($record), 'id': $rid })
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noValidResourceConstraint"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID0606b9bf-8f5a-4e71-a922-3cf6ab8c1de0">
									<label>md-iso.a.5: Specification</label>
									<description><![CDATA[<p>The test only applies, if there is at least one specification referenced. In case there is one, it performs the following checks:</p>
<ul>
<li>The specification must contain an element of type gmd:CI_Citation/gmd:title which should not be an empty characterstring.</li>
<li>The specification must contain an element of type gmd:CI_Citation/gmd:date[./*/gmd:dateType/*/text()='{type}']/*/gmd:date, where {type} is one of 'creation', 'revision' and 'publication'.</li>
<li>The specification has gmd:DQ_DomainConsistency as a parent element.</li>
</ul>
Relevant requirement(s):</p>
<ul>
<li>TG MD Requirement 29: The INSPIRE Metadata Regulation 1205/2008/EC defines in Part D 5 When the conformity to any specification has been evaluated, it shall be reported as a domain consistency element (i.e. an instance of DQ_DomainConsistency) in ISO 19115 metadata.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/ds-specification" target="_blank">Abstract Test Case 'Dataset specification'</a></p>]]></description>
									<parent ref="EID95a1a8a8-3132-453f-921a-c0334781e8bb"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>									
let $levels := ('dataset', 'series')
let $recordsToInspect := $records[gmd:hierarchyLevel/*/@codeListValue = $levels]									
let $messages := 
	(for $record in $recordsToInspect
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $specifications := $record/gmd:dataQualityInfo/*/gmd:report/gmd:DQ_DomainConsistency/gmd:result/gmd:DQ_ConformanceResult/gmd:specification
	 let $DQ_ConformanceResults := $record/gmd:dataQualityInfo/*/gmd:report/gmd:DQ_DomainConsistency/gmd:result/gmd:DQ_ConformanceResult
	 return 
	 if (not($specifications)) then local:addMessage('TR.noSpecifications', map { 'filename': local:filename($record), 'id': $rid })
	 else
	 for $DQ_ConformanceResult in $DQ_ConformanceResults
		let $spec := $DQ_ConformanceResult/gmd:specification
		return (
		if (not($spec)) then ()
		else
			if (not($spec/gmd:CI_Citation/gmd:title/*[1][string-length(normalize-space(text())) &gt; 0])) then
				local:addMessage('TR.noTitleForSpecification', map { 'filename': local:filename($record), 'id': $rid })
			else if (not($spec/gmd:CI_Citation/gmd:date/*/gmd:dateType/*[@codeListValue = ('publication','creation','revision')])) then
				local:addMessage('TR.noDateTypeForSpecification', map { 'filename': local:filename($record), 'id': $rid, 'specification':  $spec/gmd:CI_Citation/gmd:title/*[1]/text() })
			else (),
		if (not($DQ_ConformanceResult/gmd:pass/gco:Boolean)) then
			local:addMessage('TR.noBooleanValueForPass', map { 'filename': local:filename($record), 'id': $rid, 'specification':  $spec/gmd:CI_Citation/gmd:title/*[1]/text() })
		else ()
	))[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noTitleForSpecification"/>
										<translationTemplate ref="TR.noDateTypeForSpecification"/>
										<translationTemplate ref="TR.noSpecifications"/>
										<translationTemplate ref="TR.noBooleanValueForPass"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID22ba60c4-0d3a-44a1-a0b1-db2d7c75836c">
									<label>md-iso.a.6: Language</label>
									<description><![CDATA[<p>The test checks that a gmd:LanguageCode object is given at gmd:language and contains a codeListValue attribute. It is then checked if the codeListValue attribute contains a valid 3-letter language code according to ISO 639-2/B of one of the official languages.</br></br>
Relevant requirement(s):</p>
<ul>
<li>TG MD Requirement 39: The language property is not mandated by ISO 19115, but is mandated for conformance to the INSPIRE Metadata Regulation 1205/2008/EC.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/language" target="_blank">Abstract Test Case 'Language'</a></p>]]></description>
									<parent ref="EID95a1a8a8-3132-453f-921a-c0334781e8bb"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $codes := ('bul','hrv','cze','dan','dut','eng','est','fin','fre','ger','gre','hun','gle','ita','lav','lit','mlt','pol','por','rum','slo','slv','spa','swe')
let $messages :=
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $metadataLanguageCode := $record/gmd:language/gmd:LanguageCode/@codeListValue
	 return
	 if (not($metadataLanguageCode)) then
		local:addMessage('TR.noMetadataLanguageCode',  map { 'filename': local:filename($record), 'id': $rid })
	 else
		let $wrongCodeValue := not($metadataLanguageCode = $codes)
		return
		if ($wrongCodeValue) then
			local:addMessage('TR.invalidMetadataLanguageCode',  map { 'filename': local:filename($record), 'id': $rid, 'invalidCode' : data($metadataLanguageCode) })
		else ()
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noMetadataLanguageCode"/>
										<translationTemplate ref="TR.invalidMetadataLanguageCode"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID77f31952-b3e1-432f-80cc-682af11d1d5f">
									<label>md-iso.a.7: Metadata contact</label>
									<description><![CDATA[<p>The test checks, if a contact element (gmd:contact) is given. It then performs the following checks for every element:
<ul>
<li>There must not be an empty characterstring in gmd:organisationName</li>
<li>There must not be an empty characterstring in gmd:contactInfo/*/gmd:address/*/gmd:electronicMailAddress, and the characterstring must match the regular expresion '^[a-zA-Z0-9\._%\+-]+@[a-zA-Z0-9\.-]+\.[a-zA-Z]{2,}$'</li>
</ul>
Relevant requirement(s):</p>
<ul>
<li>TG MD Requirement 37: This description shall include: name of the organization and contact email address.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/md-contact" target="_blank">Abstract Test Case 'Metadata contact'</a></p>]]></description>
									<parent ref="EID95a1a8a8-3132-453f-921a-c0334781e8bb"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $regex := '^[a-zA-Z0-9\._%\+-]+@[a-zA-Z0-9\.-]+\.[a-zA-Z]{2,}$'
let $messages :=
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $pocs := $record/gmd:contact/* (: At least one gmd:contact is required - the XML Schema validation checks whether this condition is met. :)
	 return
		for $poc in $pocs
		let $organisationName := $poc/gmd:organisationName/*[1]
		let $emails := $poc/gmd:contactInfo/*/gmd:address/*/gmd:electronicMailAddress/*[1]/text()
		return
		(if (not($organisationName) or string-length(normalize-space($organisationName/text())) = 0) then
			local:addMessage('TR.noMetadataContactOrganisationName', map { 'filename': local:filename($record), 'id': $rid }) else (),
		 if (not($emails)) then
			local:addMessage('TR.noMetadataContactEmailAddress', map { 'filename': local:filename($record), 'id': $rid })
		 else if (some $email in $emails satisfies not(matches($email,$regex))) then
		 	for $email in $emails
		 	where not(matches($email,$regex))
			return
				local:addMessage('TR.invalidMetadataContactEmailAddress', map { 'filename': local:filename($record), 'id': $rid, 'email': $email })
		 else ()
		)
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noMetadataContactOrganisationName"/>
										<translationTemplate ref="TR.noMetadataContactEmailAddress"/>
										<translationTemplate ref="TR.invalidMetadataContactEmailAddress"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID71789d5a-499f-42d8-b0fb-8b723a3ebb56">
									<label>md-iso.a.8: Metadata contact role</label>
									<description><![CDATA[<p>The test checks the role information of the responsible party serving as metadata point of contact. More specifically:
<ul>
<li>Check that the metadata record contains a CI_RoleCode element under gmd:contact.</li>
<li>Check that the CI_RoleCode has an XML attribute 'codeListValue' with string value equal to "pointOfContact".</li>
</ul>
Relevant requirement(s):</p>
<ul>
<li>TG MD Requirement 38: The role of the responsible party serving as a metadata point of contact is out of scope of the INSPIRE Metadata Regulation 1205/2008/EC, but this property is mandated by ISO 19115. The default value is pointOfContact.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/md-contact-role" target="_blank">Abstract Test Case 'Metadata contact role'</a></p>]]></description>
									<parent ref="EID95a1a8a8-3132-453f-921a-c0334781e8bb"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $messages :=
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $pocs := $record/gmd:contact/* (: At least one gmd:contact is required - the XML Schema validation checks whether this condition is met. :)
	 return
	 if (some $poc in $pocs satisfies (not($poc/gmd:role/*) or not($poc/gmd:role/*/@codeListValue = 'pointOfContact'))) then
		local:addMessage('TR.noMetadataContactRole', map { 'filename': local:filename($record), 'id': $rid, 'pocs': fn:string-join($pocs/gmd:role/*/@codeListValue,', ') })
	 else ()
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noMetadataContactRole"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID8c2812df-a6d1-4016-b447-9a9100088e68">
									<label>md-iso.a.9: Resource creation date</label>
									<description><![CDATA[<p>The test checks that the metadata record does not have more than one creation date.
Relevant requirement(s):</p>
<ul>
<li>TG MD Requirement 25: There shall be a single creation date for the resource.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/resource-creation-date" target="_blank">Abstract Test Case 'Resource creation date'</a></p>]]></description>
									<parent ref="EID95a1a8a8-3132-453f-921a-c0334781e8bb"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $cl := ('CI_DateTypeCode','http://www.isotc211.org/2005/resources/codeList.xml#CI_DateTypeCode')
let $messages :=
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $creationDates := $record/gmd:identificationInfo[1]/*/gmd:citation/*/gmd:date/*[gmd:dateType/*/@codeList = $cl and gmd:dateType/*/@codeListValue = 'creation']/gmd:date/*
	 return
	 if (count($creationDates) &gt; 1) then
		local:addMessage('TR.moreThanOneCreationDate', map { 'filename': local:filename($record), 'id': $rid })
	 else ()
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.moreThanOneCreationDate"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID42cd4e69-021d-4765-ad15-f69146320b16">
									<label>md-iso.a.10: Responsible party contact info</label>
									<description><![CDATA[<p>The test checks, if a point of contact is given. It then performs the following checks for every occurance:
<ul>
<li>There must not be an empty characterstring in gmd:organisationName</li>
<li>There must not be an empty characterstring in gmd:contactInfo/*/gmd:address/*/gmd:electronicMailAddress, and the characterstring must match the regular expresion '^[a-zA-Z0-9\._%\+-]+@[a-zA-Z0-9\.-]+\.[a-zA-Z]{2,}$'</li>
</ul>
Relevant requirement(s):</p>
<ul>
<li>TG MD Requirement 35: This description shall include: name of the organisation and contact email address.</li>
<li>TG MD Requirement 36: See SC14 for more information about elements required for data and services.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/responsible-party-contact-info" target="_blank">Abstract Test Case 'Responsible party contact info'</a></p>]]></description>
									<parent ref="EID95a1a8a8-3132-453f-921a-c0334781e8bb"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $regex := '^[a-zA-Z0-9\._%\+-]+@[a-zA-Z0-9\.-]+\.[a-zA-Z]{2,}$'
let $messages :=
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $pocs := $record/gmd:identificationInfo/*/gmd:pointOfContact/*
	 return
	 if (not($pocs)) then
		local:addMessage('TR.noPointOfContact', map { 'filename': local:filename($record), 'id': $rid })
	 else
		for $poc in $pocs
		let $organisationName := $poc/gmd:organisationName/*[1]
		let $emails := $poc/gmd:contactInfo/*/gmd:address/*/gmd:electronicMailAddress/*[1]/text()
		return
		(if (not($organisationName) or string-length(normalize-space($organisationName/text())) = 0) then
			local:addMessage('TR.noPOCOrganisationName', map { 'filename': local:filename($record), 'id': $rid }) else (),
		 if (not($emails)) then
			local:addMessage('TR.noPOCEmailAddress', map { 'filename': local:filename($record), 'id': $rid })
		 else if (some $email in $emails satisfies not(matches($email,$regex))) then
		 	for $email in $emails
		 	where not(matches($email,$regex))
			return
				local:addMessage('TR.invalidPOCEmailAddress', map { 'filename': local:filename($record), 'id': $rid, 'email': $email })
		 else ()
		)
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noPOCOrganisationName"/>
										<translationTemplate ref="TR.noPOCEmailAddress"/>
										<translationTemplate ref="TR.invalidPOCEmailAddress"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EIDa876baa2-9f6d-4d23-804a-58abdaf8e39a">
									<label>md-iso.a.11: Responsible party role</label>
									<description><![CDATA[<p>The test checks the role information of the responsible party. More specifically:
<ul>
<li>Check that the metadata record contains a CI_RoleCode element under gmd:contact.</li>
<li>Check that the CI_RoleCode has an XML attribute 'codeListValue' with string value equal to one of the role codes defined by ISO 19115 CI_RoleCode (see section B.5.5 in ISO 19115).</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/responsible-party-role" target="_blank">Abstract Test Case 'Responsible party role'</a></p>]]></description>
									<parent ref="EID95a1a8a8-3132-453f-921a-c0334781e8bb"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $iso19115_CIRoleCode := ('resourceProvider','custodian','owner','user','distributor','originator','pointOfContact','principalInvestigator','processor','publisher','author')
let $messages :=
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $pocs := $record/gmd:identificationInfo/*/gmd:pointOfContact/*
	 return
	 if (not($pocs)) then
		local:addMessage('TR.noPointOfContact', map { 'filename': local:filename($record), 'id': $rid })
	 else if (some $poc in $pocs satisfies (not($poc/gmd:role/*) or not($poc/gmd:role/*/@codeListValue = $iso19115_CIRoleCode))) then
		local:addMessage('TR.noPointOfContactRole', map { 'filename': local:filename($record), 'id': $rid, 'pocs': fn:string-join($pocs/gmd:role/*/@codeListValue,', ') })
	 else ()
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noPointOfContact"/>
										<translationTemplate ref="TR.noPointOfContactRole"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>
				<TestCase id="EID2ee0045f-cf8d-4979-9d7d-76cb465a0314">
					<label>Hierarchy level</label>
					<description>The test on the information about hierarchy level of a metadata record is a pre-condition for other tests. It is therefore provided as a separate test case.</description>
					<parent ref="EID4c5d8006-3ac6-43d9-a1a3-1e19bf163ff3"/>
					<testSteps>
						<TestStep id="EID9827676c-e48f-4241-b37c-3a15393c6324">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID2ee0045f-cf8d-4979-9d7d-76cb465a0314"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EIDcacf6ca7-b5df-49e3-8577-dbc76cd6d72a">
									<label>md-iso.b.1: Hierarchy</label>
									<description><![CDATA[<p>This test checks that a resource type is provided and is taken from the list of valid values, i.e. 'dataset', 'series' or 'service'.</p>
<p>This test is a pre-condition to process INSPIRE metadata records properly.</p>
<p>Relevant requirements:</p>
<ul>
<li>TG Requirement 1: The hierarchyLevel property is not mandated by ISO 19115 but is mandated for conformance to the INSPIRE Metadata Regulation 1205/2008/EC.</li>
<li>TG Requirement 2: The values of MD_ScopeCode in the scope of the INSPIRE Directive are: 'dataset' for spatial datasets; 'series' for spatial dataset series; 'service' for spatial data services.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/hierarchy" target="_blank">Abstract Test Case 'Hierarchy'</a></p>]]></description>
									<parent ref="EID9827676c-e48f-4241-b37c-3a15393c6324"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $values := ('dataset', 'series', 'service')
let $recordsWithErrors := $records[not(gmd:hierarchyLevel/gmd:MD_ScopeCode/@codeListValue = $values)][position() le $limitErrors]
return
(if ($recordsWithErrors) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count($recordsWithErrors)),
 for $record in $recordsWithErrors
   let $rid := $record/gmd:fileIdentifier/gco:CharacterString/text()
   order by $rid
   let $levels := $record/gmd:hierarchyLevel/gmd:MD_ScopeCode/@codeListValue
   return
     local:addMessage('TR.hierarchyLevel', map { 'filename': local:filename($record), 'id': $rid, 'hierarchyLevels': fn:string-join($levels,', ') })
)
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.recordsWithErrors"/>
										<translationTemplate ref="TR.hierarchyLevel"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>
				<TestCase id="EIDb5b5b5c0-c021-4b90-9c76-9603bf17ed4c">
					<label>Dataset (series) tests</label>
					<description>Execute tests that apply for all dataset / dataset series metadata records.</description>
					<parent ref="EID4c5d8006-3ac6-43d9-a1a3-1e19bf163ff3"/>
					<dependencies>
						<testCase ref="EID2ee0045f-cf8d-4979-9d7d-76cb465a0314"/>
					</dependencies>
					<testSteps>
						<TestStep id="EID0422a7f2-4ec7-4a75-9667-38f265ea4545">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EIDb5b5b5c0-c021-4b90-9c76-9603bf17ed4c"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EIDdf3b3ecb-d429-450a-abd8-895b6c1d8e79">
									<label>md-iso.c.1: Dataset identification</label>
									<description><![CDATA[<p>If the type of the resource is a dataset (series), a unique identifier identifying the resource must be given.</p>
<p>This test case only applies to records with a hierarchyLevel value 'dataset' or 'series'.</p>
<p>The test first checks, if a unique identifier is given and if it is of type MD_Identifier or RS_Identifier. The contained code element may not be empty.</p>
<p>Relevant requirements:</p>
<ul>
<li>TG Requirement 5: The code property is required (see B.2.7.3 of ISO 19115).</li>
<li>TG Requirement 6: If a value for codeSpace is provided, then the data type for the identifier shall be RS_Identifier, which is substitutable for the usual MD_Identifier.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/ds-identification" target="_blank">Abstract Test Case 'Dataset identification'</a></p>]]></description>
									<parent ref="EID0422a7f2-4ec7-4a75-9667-38f265ea4545"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $levels := ('dataset', 'series')
let $recordsToInspect := $records[gmd:hierarchyLevel/gmd:MD_ScopeCode/@codeListValue = $levels]
let $distinctRecordIdentifiers :=
  for $rec in $records
  return
    distinct-values($rec/gmd:identificationInfo[1]/*/gmd:citation/*/gmd:identifier/*/gmd:code/*/text())
let $duplicateDistinctRecordIdentifiers := $distinctRecordIdentifiers[index-of($distinctRecordIdentifiers,.)[2]]
let $messages :=
	(for $record in $recordsToInspect
	 let $rid := $record/gmd:fileIdentifier/gco:CharacterString/text()
	 let $identifiers := $record/gmd:identificationInfo[1]/*/gmd:citation/*/gmd:identifier/*/gmd:code/*/text()
	 return
	 if (not($identifiers)) then
		local:addMessage('TR.noIdentifier', map { 'filename': local:filename($record), 'id': $rid })
	 else
		for $identifier in $identifiers
		return
		if (string-length(normalize-space($identifier)) = 0) then
			local:addMessage('TR.emptyIdentifier', map { 'filename': local:filename($record), 'id': $rid })
		else if ($identifier = $duplicateDistinctRecordIdentifiers) then
			local:addMessage('TR.duplicateIdentifier', map { 'filename': local:filename($record), 'id': $rid, 'identifier': $identifier })
		else ()
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noIdentifier"/>
										<translationTemplate ref="TR.emptyIdentifier"/>
										<translationTemplate ref="TR.duplicateIdentifier"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EIDf55fae32-c30a-4fa6-9ef4-201d5fa4d02f">
									<label>md-iso.c.2: Dataset language</label>
									<description><![CDATA[<p>If the type of the resource is dataset or series, a resource language must be given.<br/><br/>
This test case only applies to records with a hierarchyLevel value 'dataset' or 'series'.</p>
<p>The test first checks if a gmd:LanguageCode object is given (inside gmd:identificationInfo), containing a codeListValue attribute with a valid 3-letter language code (see the values of enumeration type languageISO6392B in <a href="http://inspire.ec.europa.eu/schemas/common/1.0/common.xsd" target="_blank">http://inspire.ec.europa.eu/schemas/common/1.0/common.xsd</a>).</p>
<p>Relevant requirements:</p>
<ul>
<li>TG MD Requirement 8: The resource language is mandated by ISO 19115.</li>
<li>TG MD Requirement 9: The resource language has to be filled with a value from the codelist ISO/TS 19139 based on alpha-3 codes of ISO 639-2.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/ds-language" target="_blank">Abstract Test Case 'Dataset language'</a></p>]]></description>
									<parent ref="EID0422a7f2-4ec7-4a75-9667-38f265ea4545"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $recordsToInspect := $records[gmd:hierarchyLevel/gmd:MD_ScopeCode/@codeListValue = ('dataset','series')]
let $codes := ('aar','abk','ace','ach','ada','ady','afa','afh','afr','ain','aka','akk','alb','ale','alg','alt','amh','ang','anp','apa','ara','arc','arg','arm','arn','arp','art','arw','asm','ast','ath','aus','ava','ave','awa','aym','aze','bad','bai','bak','bal','bam','ban','baq','bas','bat','bej','bel','bem','ben','ber','bho','bih','bik','bin','bis','bla','bnt','bos','bra','bre','btk','bua','bug','bul','bur','byn','cad','cai','car','cat','cau','ceb','cel','cha','chb','che','chg','chi','chk','chm','chn','cho','chp','chr','chu','chv','chy','cmc','cop','cor','cos','cpe','cpf','cpp','cre','crh','crp','csb','cus','cze','dak','dan','dar','day','del','den','dgr','din','div','doi','dra','dsb','dua','dum','dut','dyu','dzo','efi','egy','eka','elx','eng','enm','epo','est','ewe','ewo','fan','fao','fat','fij','fil','fin','fiu','fon','fre','frm','fro','frr','frs','fry','ful','fur','gaa','gay','gba','gem','geo','ger','gez','gil','gla','gle','glg','glv','gmh','goh','gon','gor','got','grb','grc','gre','grn','gsw','guj','gwi','hai','hat','hau','haw','heb','her','hil','him','hin','hit','hmn','hmo','hrv','hsb','hun','hup','iba','ibo','ice','ido','iii','ijo','iku','ile','ilo','ina','inc','ind','ine','inh','ipk','ira','iro','ita','jav','jbo','jpn','jpr','jrb','kaa','kab','kac','kal','kam','kan','kar','kas','kau','kaw','kaz','kbd','kha','khi','khm','kho','kik','kin','kir','kmb','kok','kom','kon','kor','kos','kpe','krc','krl','kro','kru','kua','kum','kur','kut','lad','lah','lam','lao','lat','lav','lez','lim','lin','lit','lol','loz','ltz','lua','lub','lug','lui','lun','luo','lus','mac','mad','mag','mah','mai','mak','mal','man','mao','map','mar','mas','may','mdf','mdr','men','mga','mic','min','mis','mkh','mlg','mlt','mnc','mni','mno','moh','mon','mos','mul','mun','mus','mwl','mwr','myn','myv','nah','nai','nap','nau','nav','nbl','nde','ndo','nds','nep','new','nia','nia','nic','niu','nno','nob','nog','non','nor','nqo','nso','nub','nwc','nya','nym','nyn','nyo','nzi','oci','oji','ori','orm','osa','oss','ota','oto','paa','pag','pal','pam','pan','pap','pau','peo','per','phi','phn','pli','pol','pon','por','pra','pro','pus','qaa-qtz','que','raj','rap','rar','roa','roh','rom','rum','run','rup','rus','sad','sag','sah','sai','sal','sam','san','sas','sat','scn','sco','sel','sem','sga','sgn','shn','sid','sin','sio','sit','sla','slo','slv','sma','sme','smi','smj','smn','smo','sms','sna','snd','snk','sog','som','son','sot','spa','srd','srn','srp','srr','ssa','ssw','suk','sun','sus','sux','swa','swe','syc','syr','tah','tai','tam','tat','tel','tem','ter','tet','tgk','tgl','tha','tib','tig','tir','tiv','tkl','tlh','tli','tmh','tog','ton','tpi','tsi','tsn','tso','tuk','tum','tup','tur','tut','tvl','twi','tyv','udm','uga','uig','ukr','umb','und','urd','uzb','vai','ven','vie','vol','vot','wak','wal','war','was','wel','wen','wln','wol','xal','xho','yao','yap','yid','yor','ypk','zap','zbl','zen','zha','znd','zul','zun','zxx','zza')
let $messages :=
	if (not($recordsToInspect)) then ()
	else
	(for $record in $recordsToInspect
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $languageCodes := $record/gmd:identificationInfo[1]/*/gmd:language/gmd:LanguageCode
	 return
	 if (not($languageCodes)) then
		local:addMessage('TR.noLanguageCode',  map { 'filename': local:filename($record), 'id': $rid })
	 else
		let $wrongCodeValues := $languageCodes/@codeListValue[not(. = $codes)]
		return
		if ($wrongCodeValues) then
		local:addMessage('TR.invalidLanguageCode',  map { 'filename': local:filename($record), 'id': $rid, 'invalidCodes' : string-join($wrongCodeValues,', ') })
		else ()
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noLanguageCode"/>
										<translationTemplate ref="TR.invalidLanguageCode"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EIDbab97b1b-4ffe-4ac7-be22-16d10e3ed3dd">
									<label>md-iso.c.3: Dataset linkage</label>
									<description><![CDATA[<p>This test checks each resource locator URL, if it is syntactically correct and if the resource it references can be accessed, in order to determine its type. If the referenced resource is recognized as a Network Service, it checks whether the linkage to the dataset is declared and implemented.</p>
<p>This test case only applies to records with a hierarchyLevel value 'dataset' or 'series'.</p>
<p>The test checks if a linkage is provided. If none is given, the test will complete successfully. If one or more are provided, for each linkage the test checks:</p>
<ul>
<li>if the linkage element contains an element of type gmd:URL.</li>
<li>if the element content is a syntactically correct URL.</li>
<li>if the referenced resource is accessible.</li>
<li>if the response identifies the linkage as a known Harmonised Spatial Data Service type or a Network Service type, the test checks if appropriate linkage to dataset is available. The linkage is established via the Metadata URL for WMS, WFS, WCS, SOS and Atom based services. Otherwise a final manual test is suggested to the tester (to test if any of the linkages points to a webpage with further instructions or a client application that directly accesses the service).</li>
</ul>
<p>Relevant requirements:</p>
<ul>
<li>TG Requirement 3: If a linkage for data is available, the Resource Locator shall be a valid URL providing one of the following: a link to a web page with further instructions, a link to a service capabilities document, a link to the service WSDL document (SOAP Binding), a link to a client application that directly accesses the service.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/ds-linkage" target="_blank">Abstract Test Case 'Dataset linkage'</a></p>]]></description>
									<parent ref="EID0422a7f2-4ec7-4a75-9667-38f265ea4545"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $levels := ('dataset', 'series')
let $recordsToInspect := $records[gmd:hierarchyLevel/gmd:MD_ScopeCode/@codeListValue = $levels and gmd:distributionInfo/*/gmd:transferOptions/*/gmd:onLine/*/gmd:linkage]
let $urls := fn:distinct-values($recordsToInspect/gmd:distributionInfo/*/gmd:transferOptions/*/gmd:onLine/*/gmd:linkage/gmd:URL/text())
let $map := local:check-resource-uris($urls, 30, true())
let $first_validation := (for $record in $recordsToInspect
  let $urls := $record/gmd:distributionInfo/*/gmd:transferOptions/*/gmd:onLine/*/gmd:linkage/gmd:URL/text()
  return
  if (not($urls)) then ()
  else
  for $url in $urls
    let $validuri := map:get($map, $url)
    return
    if ($validuri = 'notHTTP') then ()
    else if ($validuri = 'idNotFound') then ()
    else if (starts-with($validuri, 'EXCEPTION')) then ()
    else if (matches($validuri,'^\d{3}$')) then ()
    else if (starts-with($validuri,'text/xml') or starts-with($validuri,'application/xml') or starts-with($validuri,'application/vnd.ogc.')) then
      try { 
      	let $root := fn:doc($url)/element()
        	return
        	if ($root[self::wfs:WFS_Capabilities or self::wms:WMS_Capabilities or self::wcs:Capabilities or self::sos:Capabilities or self::atom:feed]) then 'validuri'
			else ()
		} catch * { 
      }
    else ())[position() le $limitErrors]
let $messages := (for $record in $recordsToInspect
  let $rid := $record/gmd:fileIdentifier/*/text()
  let $urls := $record/gmd:distributionInfo/*/gmd:transferOptions/*/gmd:onLine/*/gmd:linkage/gmd:URL/text()
  return
  if (not($urls)) then
    local:addMessage('TR.linkageWithoutURL', map { 'filename': local:filename($record), 'id': $rid })
  else
  for $url in $urls
    let $validuri := map:get($map, $url)
    return
    if ($validuri = 'notHTTP') then
	   local:addMessage('TR.urlNotHttp', map { 'filename': local:filename($record), 'id': $rid, 'url': $url })
    else if ($validuri = 'idNotFound') then
	   local:addMessage('TR.idNotFound', map { 'filename': local:filename($record), 'id': $rid, 'url': $url })
    else if (starts-with($validuri, 'EXCEPTION')) then
		local:addMessage('TR.resourceNotAccessibleException', map { 'filename': local:filename($record), 'id': $rid, 'url': $url, 'message': substring-after($validuri, 'EXCEPTION ') })
    else if (matches($validuri,'^\d{3}$')) then
		local:addMessage('TR.resourceNotAccessible', map { 'filename': local:filename($record), 'id': $rid, 'url': $url, 'status' : $validuri })
    else if (starts-with($validuri,'text/xml') or starts-with($validuri,'application/xml') or starts-with($validuri,'application/vnd.ogc.')) then
	  if ($first_validation = 'validuri') then ()
	  else
		  try {
			let $root := fn:doc($url)/element()
			return
			if ($root[self::wfs:WFS_Capabilities or self::wms:WMS_Capabilities or self::wcs:Capabilities or self::sos:Capabilities or self::atom:feed]) then ()
			else local:addMessage('TR.unknownXMLResource', map { 'filename': local:filename($record), 'id': $rid, 'url': $url, 'elementName': local-name($root), 'namespace': namespace-uri($root) })
		  } catch * {
				local:addMessage('TR.resourceNotAccessibleException', map { 'filename': local:filename($record), 'id': $rid, 'url': $url, 'message': $err:description })
		  }
    else
       local:addMessage('TR.unknownResourceType', map { 'filename': local:filename($record), 'id': $rid, 'url': $url, 'mediaType': $validuri }))[position() le $limitErrors]
return
	(if ($messages//@ref = ('TR.linkageWithoutURL', 'TR.idNotFound2', 'TR.urlNotHttp', 'TR.resourceNotAccessible', 'TR.resourceNotAccessibleException')) then 'FAILED' else if ($messages) then 'PASSED_MANUAL' else 'PASSED',
	 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
	 $messages)
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.recordsWithErrors"/>
										<translationTemplate ref="TR.linkageWithoutURL"/>
										<translationTemplate ref="TR.urlNotHttp"/>
										<translationTemplate ref="TR.idNotFound"/>
										<translationTemplate ref="TR.resourceNotAccessibleException"/>
										<translationTemplate ref="TR.resourceNotAccessible"/>
										<translationTemplate ref="TR.unknownXMLResource"/>
										<translationTemplate ref="TR.unknownResourceType"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID4148f8be-19d3-4def-b7da-2f451f5c8e1f">
									<label>md-iso.c.4: Dataset conformity</label>
									<description><![CDATA[<p>The metadata shall include information on the degree of conformity with the implementing rules on interoperability of spatial data sets and services.</p>
<p>The test checks that at least one conformity statement with a conformance result is given. A conformance result must either have a boolean value or state (via a nilReason attribute) that the conformance is 'unknown'.</p>
<p>Relevant requirements:</p>
<ul>
<li>TG MD Requirement 28: In conformance to INSPIRE Directive 2007/2/EC, the metadata shall include information on the degree of conformity with the implementing rules on interoperability of spatial data sets and services.</li>
<li>TG MD Requirement 29: The INSPIRE Metadata Regulation 1205/2008/EC defines in Part D 5 When the conformity to any specification has been evaluated, it shall be reported as a domain consistency element (i.e. an instance of DQ_DomainConsistency) in ISO 19115 metadata.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/ds-conformity" target="_blank">Abstract Test Case 'Dataset conformity'</a></p>]]></description>
									<parent ref="EID0422a7f2-4ec7-4a75-9667-38f265ea4545"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $levels := ('dataset', 'series')
let $recordsToInspect := $records[gmd:hierarchyLevel/*/@codeListValue = $levels]
let $regulation := (lower-case("РЕГЛАМЕНТ (ЕС) № 1089/2010 НА КОМИСИЯТА от 23 ноември 2010 година за прилагане на Директива 2007/2/ЕО на Европейския парламент и на Съвета по отношение на оперативната съвместимост на масиви от пространствени данни и услуги за пространствени данни"), lower-case("NAŘÍZENÍ KOMISE (EU) č. 1089/2010 ze dne 23. listopadu 2010, kterým se provádí směrnice Evropského parlamentu a Rady 2007/2/ES, pokud jde o interoperabilitu sad prostorových dat a služeb prostorových dat"), lower-case("KOMMISSIONENS FORORDNING (EU) Nr. 1089/2010 af 23. november 2010 om gennemførelse af Europa-Parlamentets og Rådets direktiv 2007/2/EF for så vidt angår interoperabilitet for geodatasæt og -tjenester"), lower-case("VERORDENING (EU) Nr. 1089/2010 VAN DE COMMISSIE van 23 november 2010 ter uitvoering van Richtlijn 2007/2/EG van het Europees Parlement en de Raad betreffende de interoperabiliteit van verzamelingen ruimtelijke gegevens en van diensten met betrekking tot ruimtelijke gegevens"), lower-case("COMMISSION REGULATION (EU) No 1089/2010 of 23 November 2010 implementing Directive 2007/2/EC of the European Parliament and of the Council as regards interoperability of spatial data sets and services"), lower-case("KOMISJONI MÄÄRUS (EL) nr 1089/2010, 23. november 2010, millega rakendatakse Euroopa Parlamendi ja nõukogu direktiivi 2007/2/EÜ seoses ruumiandmekogumite ja -teenuste ristkasutatavusega"), lower-case("KOMISSION ASETUS (EU) N:o 1089/2010, annettu 23 päivänä marraskuuta 2010, Euroopan parlamentin ja neuvoston direktiivin 2007/2/EY täytäntöönpanosta paikkatietoaineistojen ja -palvelujen yhteentoimivuuden osalta"), lower-case("RÈGLEMENT (UE) No 1089/2010 DE LA COMMISSION du 23 novembre 2010 portant modalités d'application de la directive 2007/2/CE du Parlement européen et du Conseil en ce qui concerne l'interopérabilité des séries et des services de données géographiques"), lower-case("VERORDNUNG (EG) Nr. 1089/2010 DER KOMMISSION vom 23. November 2010 zur Durchführung der Richtlinie 2007/2/EG des Europäischen Parlaments und des Rates hinsichtlich der Interoperabilität von Geodatensätzen und -diensten"), lower-case("COMMISSION REGULATION (EU) No 1089/2010 of 23 November 2010 implementing Directive 2007/2/EC of the European Parliament and of the Council as regards interoperability of spatial data sets and services"), lower-case("ΚΑΝΟΝΙΣΜΟΣ (ΕΕ) αριθ. 1089/2010 ΤΗΣ ΕΠΙΤΡΟΠΗΣ της 23ης Νοεμβρίου 2010 σχετικά με την εφαρμογή της οδηγίας 2007/2/ΕΚ του Ευρωπαϊκού Κοινοβουλίου και του Συμβουλίου όσον αφορά τη διαλειτουργικότητα των συνόλων και των υπηρεσιών χωρικών δεδομένων"), lower-case("A BIZOTTSÁG 1089/2010/EU RENDELETE (2010. november 23.) a 2007/2/EK európai parlamenti és tanácsi irányelv téradatkészletek és -szolgáltatások interoperabilitására vonatkozó rendelkezéseinek végrehajtásáról"), lower-case("REGOLAMENTO (UE) N. 1089/2010 DELLA COMMISSIONE del 23 novembre 2010 recante attuazione della direttiva 2007/2/CE del Parlamento europeo e del Consiglio per quanto riguarda l'interoperabilità dei set di dati territoriali e dei servizi di dati territoriali"), lower-case("KOMISIJAS REGULA (ES) Nr. 1089/2010 (2010. gada 23. novembris), ar kuru īsteno Eiropas Parlamenta un Padomes Direktīvu 2007/2/EK attiecībā uz telpisko datu kopu un telpisko datu pakalpojumu savstarpējo izmantojamību"), lower-case("KOMISIJOS REGLAMENTAS (ES) Nr. 1089/2010 2010 m. lapkričio 23 d. kuriuo įgyvendinamos Europos Parlamento ir Tarybos direktyvos 2007/2/EB nuostatos dėl erdvinių duomenų rinkinių ir paslaugų sąveikumo"), lower-case("REGOLAMENT TAL-KUMMISSJONI (UE) Nru 1089/2010 tat-23 ta' Novembru 2010 li jimplimenta d-Direttiva 2007/2/KE tal-Parlament Ewropew u tal-Kunsill fir-rigward tal- interoperabbiltà tas-settijiet ta’ dejta u servizzi ġeografiċi"), lower-case("ROZPORZĄDZENIE KOMISJI (UE) NR 1089/2010 z dnia 23 listopada 2010 r. w sprawie wykonania dyrektywy 2007/2/WE Parlamentu Europejskiego i Rady w zakresie interoperacyjności zbiorów i usług danych przestrzennych"), lower-case("REGULAMENTO (UE) N. o 1089/2010 DA COMISSÃO de 23 de Novembro de 2010 que estabelece as disposições de execução da Directiva 2007/2/CE do Parlamento Europeu e do Conselho relativamente à interoperabilidade dos conjuntos e serviços de dados geográficos"), lower-case("REGULAMENTUL (UE) NR. 1089/2010 AL COMISIEI din 23 noiembrie 2010 de punere în aplicare a Directivei 2007/2/CE a Parlamentului European şi a Consiliului în ceea ce priveşte interoperabilitatea seturilor şi serviciilor de date spaţiale"), lower-case("NARIADENIE KOMISIE (EÚ) č. 1089/2010 z 23. novembra 2010, ktorým sa vykonáva smernica Európskeho parlamentu a Rady 2007/2/ES, pokiaľ ide o interoperabilitu súborov a služieb priestorových údajov"), lower-case("UREDBA KOMISIJE (EU) št. 1089/2010 z dne 23. novembra 2010 o izvajanju Direktive 2007/2/ES Evropskega parlamenta in Sveta glede medopravilnosti zbirk prostorskih podatkov in storitev v zvezi s prostorskimi podatki"), lower-case("REGLAMENTO (UE) No 1089/2010 DE LA COMISIÓN de 23 de noviembre de 2010 por el que se aplica la Directiva 2007/2/CE del Parlamento Europeo y del Consejo en lo que se refiere a la interoperabilidad de los conjuntos y los servicios de datos espaciales"), lower-case("KOMMISSIONENS FÖRORDNING (EU) nr 1089/2010 av den 23 november 2010 om genomförande av Europaparlamentets och rådets direktiv 2007/2/EG vad gäller interoperabilitet för rumsliga datamängder och datatjänster"), lower-case("UREDBA KOMISIJE (EU) br. 1089/2010 od 23. studenoga 2010 o provedbi Direktive 2007/2/EZ Europskog parlamenta i Vijeca o meduoperativnosti skupova prostornih podataka i usluga u vezi s prostornim podacima"))
let $messages := 
	(for $record in $recordsToInspect
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $confResPasses := $record/gmd:dataQualityInfo/*/gmd:report/gmd:DQ_DomainConsistency/gmd:result/gmd:DQ_ConformanceResult/gmd:pass
	 let $DQ_ConformanceResults := $record/gmd:dataQualityInfo/*/gmd:report/gmd:DQ_DomainConsistency/gmd:result/gmd:DQ_ConformanceResult
	 let $hasExpectedCitation := boolean($DQ_ConformanceResults/*/gmd:CI_Citation[normalize-space(lower-case(gmd:title/*/text())) = $regulation and gmd:date/*/gmd:dateType/*/@codeListValue = 'publication' and gmd:date/*/gmd:date/*/text() = '2010-12-08'])
	 return 
	 if (not($DQ_ConformanceResults)) then
			local:addMessage('TR.noDQConformanceResults', map { 'filename': local:filename($record), 'id': $rid })
	 else if (not($hasExpectedCitation)) then
		local:addMessage('TR.noExpectedCitation', map { 'filename': local:filename($record), 'id': $rid })
	 else if (not($confResPasses)) then
		local:addMessage('TR.noConformityStatement', map { 'filename': local:filename($record), 'id': $rid })
	 else
		for $confResPass in $confResPasses
		return
		if (not($confResPass/*) and not($confResPass/@gco:nilReason = 'unknown')) then
			local:addMessage('TR.declareNoConformityEvaluationAsUnknown', map { 'filename': local:filename($record), 'id': $rid })
		else () (: Schema validation will ensure that the content of $confResPass is a gco:Boolean with boolean value :)
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noDQConformanceResults"/>
										<translationTemplate ref="TR.noExpectedCitation"/>
										<translationTemplate ref="TR.noConformityStatement"/>
										<translationTemplate ref="TR.declareNoConformityEvaluationAsUnknown"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID70e46073-f58a-4dce-a1ce-b094e20089ac">
									<label>md-iso.c.5: Dataset topic</label>
									<description><![CDATA[<p>The test checks, if at least one non-empty topicCategory element is given.<p>
<p>This test case only applies to records with a hierarchyLevel value 'dataset' or 'series'.</p>
<p>For each topic category it is checked that the category is of type MD_TopicCategoryCode.</p>
<p>Whether the value is from the enumeration defined by ISO 19115 has already been tested by the XML Schema validation.</p>
<p>Relevant requirements:</p>
<ul>
<li>TG MD Requirement 10: The topic category has to be filled with a value from the enumeration MD_TopicCategoryCode (ISO 19115).</li>
<li>TG MD Requirement 11: The value saved in the XML metadata element shall be a language neutral name (see the value appearing in the “name” column of the table in B.5.27 of ISO 19115).</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/ds-topic" target="_blank">Abstract Test Case 'Dataset topic'</a></p>]]></description>
									<parent ref="EID0422a7f2-4ec7-4a75-9667-38f265ea4545"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $recordsToInspect := $records[gmd:hierarchyLevel/gmd:MD_ScopeCode/@codeListValue = ('dataset','series')]
let $messages :=
	(for $record in $recordsToInspect
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $topicCategories := $record/gmd:identificationInfo[1]/*/gmd:topicCategory/*
	 return
	 if (not($topicCategories[self::gmd:MD_TopicCategoryCode])) then
		local:addMessage('TR.noTopicCategory',  map { 'filename': local:filename($record), 'id': $rid})
	 else () (: XML Schema validation takes care of correct element content:)
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noTopicCategory"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EIDdd254a75-cd7a-4e59-9e9d-b38e251376b1">
									<label>md-iso.c.6: Dataset geographic Bounding box</label>
									<description><![CDATA[<p>This test checks if the metadata record has a valid geographic extent, expressed as a geographic bounding box with four coordinates (westBoundLongitude, eastBoundLongitude, southBoundLatitude, and northBoundLatitude). In addition, the bounding box shall be as small as possible. This requires a manual check.</p>
<p>This test case only applies to records with a hierarchyLevel value 'dataset' or 'series'.</p>
<p>The test checks if:</p>
<ul>
<li>a correctly formatted westBoundLongitude is given at gmd:westBoundLongitude/gco:Decimal</li>
<li>the following constraint is fulfilled: -180.00 ≤ westBoundLongitude ≤ 180.00</li>
<li>a correctly formatted eastBoundLongitude is given at gmd:eastBoundLongitude/gco:Decimal</li>
<li>the following constraint is fulfilled: -180.00 ≤ eastBoundLongitude ≤ 180.00</li>
<li>a correctly formatted southBoundLatitude is given at gmd:southBoundLatitude/gco:Decimal</li>
<li>the following constraint is fulfilled: -90.00 ≤ southBoundLatitude ≤ northBoundLatitude</li>
<li>a correctly formatted northBoundLatitude is given at gmd:northBoundLatitude/gco:Decimal</li>
<li>the following constraint is fulfilled: southBoundLatitude ≤ northBoundLatitude ≤ 90.00</li>
</ul>
<p>Relevant requirements:</p>
<ul>
<li>TG MD Requirement 20: The bounding box shall be as small as possible.</li>
<li>TG MD Requirement 21: The bounding box shall be expressed in decimal degree with a precision of at least 2 decimals.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/geographic-bounding-box" target="_blank">Abstract Test Case 'Geographic bounding box'</a></p>]]></description>
									<parent ref="EID0422a7f2-4ec7-4a75-9667-38f265ea4545"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $levels := ('dataset', 'series')
let $regex := '^-?\d+\.\d{2,}'
let $recordsToInspect := $records[gmd:hierarchyLevel/gmd:MD_ScopeCode/@codeListValue = $levels]
let $messages :=
	(for $record in $recordsToInspect
	 let $rid := $record/gmd:fileIdentifier/gco:CharacterString/text()
	 let $bboxes := $record/gmd:identificationInfo[1]/*/gmd:extent/*/gmd:geographicElement/gmd:EX_GeographicBoundingBox
	 return
	 if (not($bboxes)) then
		local:addMessage('TR.noGeographicBoundingBox', map { 'filename': local:filename($record), 'id': $rid })
	 else
		let $invalidbboxes :=
			for $bbox in $bboxes
			let $west := $bbox/gmd:westBoundLongitude/*/text()
			let $east := $bbox/gmd:eastBoundLongitude/*/text()
			let $south := $bbox/gmd:southBoundLatitude/*/text()
			let $north := $bbox/gmd:northBoundLatitude/*/text()
			return
			if (($west and matches($west,$regex) and fn:number($west) &gt;= -180 and fn:number($west) &lt;= 180) and
				 ($east and matches($east,$regex) and fn:number($east) &gt;= -180 and fn:number($east) &lt;= 180) and
				 ($south and matches($south,$regex) and fn:number($south) &gt;= -90 and fn:number($south) &lt;= 90) and
				 ($north and matches($north,$regex) and fn:number($north) &gt;= -90 and fn:number($north) &lt;= 90) and
				 (fn:number($south) &lt;= fn:number($north))
				) then ()
			else $bbox
		return
		if ($invalidbboxes) then
			for $bbox in $invalidbboxes
			let $west := $bbox/gmd:westBoundLongitude/*/text()
			let $east := $bbox/gmd:eastBoundLongitude/*/text()
			let $south := $bbox/gmd:southBoundLatitude/*/text()
			let $north := $bbox/gmd:northBoundLatitude/*/text()
			return
			local:addMessage('TR.invalidGeographicBoundingBox', map { 'filename': local:filename($record), 'id': $rid, 'west': $west, 'east': $east, 'south': $south, 'north': $north })
		else ()
	)[position() le $limitErrors]
return
(if ($messages//@ref = ('TR.noGeographicBoundingBox','TR.invalidGeographicBoundingBox')) then 'FAILED' else if ($recordsToInspect) then 'PASSED_MANUAL' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noGeographicBoundingBox"/>
										<translationTemplate ref="TR.invalidGeographicBoundingBox"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							 <TestAssertion id="EIDa0f2aec6-ab49-4f55-be5f-8dd06358eff7">
							  <label>md-iso.c.7: Dataset lineage</label>
							  <description><![CDATA[<p>This test checks that exactly one (non-empty) explanation about the lineage of a dataset is given.</p>
<p>This test case only applies to records with a hierarchyLevel value 'dataset' or 'series'.</p>
<p>Relevant requirements:</p>
<ul>
<li>TG MD Requirement 26: There shall be one and only one set of quality information scoped to the full resource and having a lineage statement (dataQualityInfo element). This element shall be scoped to the full data set (series) and have one lineage element. The statement sub-element of the lineage element shall be used to implement the Lineage element defined in the Implementing Rules for Metadata.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/lineage" target="_blank">Abstract Test Case 'Lineage'</a></p>]]></description>
							  <parent ref="EID0422a7f2-4ec7-4a75-9667-38f265ea4545"/>
							  <expectedResult>NOT_APPLICABLE</expectedResult>
							  <expression>
let $recordsToInspect := $records[gmd:hierarchyLevel/gmd:MD_ScopeCode/@codeListValue = ('dataset','series')]
let $messages :=
	(for $record in $recordsToInspect
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $lineageStatement := $record/gmd:dataQualityInfo/*/gmd:lineage/*/gmd:statement/*[1]
	 return
	 if (count($lineageStatement) ne 1) then
		local:addMessage('TR.wrongNumberOfLineageStatements',  map { 'filename': local:filename($record), 'id': $rid, 'count': string(count($lineageStatement)) })
	 else if (string-length(normalize-space($lineageStatement/text())) = 0) then
		local:addMessage('TR.emptyLineageStatement',  map { 'filename': local:filename($record), 'id': $rid })
	 else ()
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
							  <testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
							  <translationTemplates>
							   <translationTemplate ref="TR.wrongNumberOfLineageStatements"/>
							   <translationTemplate ref="TR.emptyLineageStatement"/>
							   <translationTemplate ref="TR.recordsWithErrors"/>
							  </translationTemplates>
							 </TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>
				<TestCase id="EID32301fad-c617-47a7-b07c-3c5f45802349">
					<label>Service tests</label>
					<description>Execute tests that apply for all service metadata records.</description>
					<parent ref="EID4c5d8006-3ac6-43d9-a1a3-1e19bf163ff3"/>
					<dependencies>
						<testCase ref="EID2ee0045f-cf8d-4979-9d7d-76cb465a0314"/>
					</dependencies>
					<testSteps>
						<TestStep id="EID1c897122-b9cc-4d27-806e-e527630a23b1">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID32301fad-c617-47a7-b07c-3c5f45802349"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EIDc56edb44-6ad0-42f8-9c42-b34caa635f70">
									<label>md-iso.d.1: Service type</label>
									<description><![CDATA[<p>This test checks if each service metadata record has exactly one name describing the type of the service.</p>
<p>If the type of the resource is service, exactly one name describing the type of service must be given. First, a check is performed to establish whether the serviceType element occurs exactly once in the document. The test then checks if the element serviceType contains text that equals one of the types given in <a href="http://inspire.ec.europa.eu/metadata-codelist/SpatialDataServiceType">EU commission regulation No. 1205/2008, Annex part D, No. 3</a>.</p>
<p>Relevant requirement(s):</p>
<ul>
<li>TG Requirement 12: Use language neutral name from table in 1.3.1.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/srv-type" target="_blank">Abstract Test Case 'Service type'</a></p>]]></description>
									<parent ref="EID1c897122-b9cc-4d27-806e-e527630a23b1"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $recordsToInspect := $records[gmd:hierarchyLevel/gmd:MD_ScopeCode/@codeListValue = 'service']
let $messages :=
	if (not($recordsToInspect)) then ()
	else
		let $spatialDataServiceTypeCodeListURL := 'http://inspire.ec.europa.eu/metadata-codelist/SpatialDataServiceType'
		let $codes := ('discovery','view','download','transformation','invoke','other')
		return
		(for $record in $recordsToInspect
		 let $rid := $record/gmd:fileIdentifier/*/text()
		 let $type := $record/gmd:identificationInfo/*/srv:serviceType/*[1]/text()
		 return
		 if (not(count($type) = 1)) then
			local:addMessage('TR.exactlyOneServiceType', map { 'filename': local:filename($record), 'id': $rid, 'count': string(count($type)) })
		 else if(not($type = $codes)) then
			local:addMessage('TR.noTypeFromSpatialDataServiceType',  map { 'filename': local:filename($record), 'id': $rid, 'url': $spatialDataServiceTypeCodeListURL, 'type': $type })
		 else ()
	)[position() le $limitErrors]
return
(if ($messages//@ref = ('TR.exactlyOneServiceType','TR.noTypeFromSpatialDataServiceType','TR.systemError')) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
			      </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.exactlyOneServiceType"/>
										<translationTemplate ref="TR.noTypeFromSpatialDataServiceType"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EIDd980cae1-6363-470f-b714-7cf253470f18">
									<label>md-iso.d.2: Service linkage</label>
									<description><![CDATA[<p>This test checks each resource locator URL to see if it is syntactically correct and if the resource it references can be accessed, in order to determine its type. If the referenced resource is recognized as a Network Service, it checks whether the linkage to the dataset is declared and implemented.</p>
<p>This test case only applies to records with a hierarchyLevel value 'service'.</p>
<p>The test checks if a linkage is provided. If none is given, the test will complete successfully. If one or more are provided, for each linkage the test checks:</p>
<ul>
<li>if the linkage element contains an element of type gmd:URL.</li>
<li>if the element content is a syntactically correct URL.</li>
<li>if the referenced resource is accessible.</li>
<li>if the response identifies the linkage is a service capabilities document consistent with an INSPIRE technical guidance, some basic parameters in the service response are analysed, if possible. Otherwise a final manual test is suggested, for example, to test if any of the linkages points to a webpage with further instructions or a client application that directly accesses the service.</li>
</ul>
<p>Relevant requirements:</p>
<ul>
<li>TG Requirement 4: If a linkage for a service is available, the Resource Locator shall be a valid URL providing one of the following: a link to a web with further instructions, a link to a service capabilities document, a link to the service WSDL document (SOAP Binding), or a link to a client application that directly accesses the service.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/srv-linkage" target="_blank">Abstract Test Case 'Service linkage'</a></p>]]></description>
									<parent ref="EID1c897122-b9cc-4d27-806e-e527630a23b1"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $recordsToInspect := $records[gmd:hierarchyLevel/gmd:MD_ScopeCode/@codeListValue = 'service' and gmd:distributionInfo/*/gmd:transferOptions/*/gmd:onLine/*/gmd:linkage]
let $urls := fn:distinct-values($recordsToInspect/gmd:distributionInfo/*/gmd:transferOptions/*/gmd:onLine/*/gmd:linkage/gmd:URL/text())
let $map := local:check-resource-uris($urls, 30, true())
let $messages := (for $record in $recordsToInspect
  let $rid := $record/gmd:fileIdentifier/*/text()
  let $urls := $record/gmd:distributionInfo/*/gmd:transferOptions/*/gmd:onLine/*/gmd:linkage/gmd:URL/text()
  return
  if (not($urls)) then
    local:addMessage('TR.linkageWithoutURL', map { 'filename': local:filename($record), 'id': $rid })
  else
  for $url in $urls
    let $validuri := map:get($map, $url)
    return
    if ($validuri = 'notHTTP') then
	   local:addMessage('TR.urlNotHttp', map { 'filename': local:filename($record), 'id': $rid, 'url': $url })
    else if ($validuri = 'idNotFound') then
	   local:addMessage('TR.idNotFound', map { 'filename': local:filename($record), 'id': $rid, 'url': $url })
    else if (starts-with($validuri, 'EXCEPTION')) then
		local:addMessage('TR.resourceNotAccessibleException', map { 'filename': local:filename($record), 'id': $rid, 'url': $url, 'message': substring-after($validuri, 'EXCEPTION ') })
    else if (matches($validuri,'^\d{3}$')) then
		local:addMessage('TR.resourceNotAccessible', map { 'filename': local:filename($record), 'id': $rid, 'url': $url, 'status' : $validuri })
    else if (starts-with($validuri,'text/xml') or starts-with($validuri,'application/xml') or starts-with($validuri,'application/vnd.ogc.') or starts-with($validuri,'application/atom')) then
      try { 
      	let $root := fn:doc($url)/element()
        	return
        	if ($root[self::wfs:WFS_Capabilities or self::wms:WMS_Capabilities or self::wcs:Capabilities or self::sos:Capabilities or self::atom:feed]) then ()
			else local:addMessage('TR.unknownXMLResource', map { 'filename': local:filename($record), 'id': $rid, 'url': $url, 'elementName': local-name($root), 'namespace': namespace-uri($root) })
		} catch * {
			local:addMessage('TR.resourceNotAccessibleException', map { 'filename': local:filename($record), 'id': $rid, 'url': $url, 'message': $err:description })
      }
    else
       local:addMessage('TR.unknownResourceType', map { 'filename': local:filename($record), 'id': $rid, 'url': $url, 'mediaType': $validuri }))[position() le $limitErrors]
return
	(if ($messages//@ref = ('TR.linkageWithoutURL', 'TR.idNotFound', 'TR.urlNotHttp', 'TR.resourceNotAccessible', 'TR.resourceNotAccessibleException')) then 'FAILED' else if ($messages) then 'PASSED_MANUAL' else 'PASSED',
	 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
	 $messages)
									</expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.recordsWithErrors"/>
										<translationTemplate ref="TR.linkageWithoutURL"/>
										<translationTemplate ref="TR.urlNotHttp"/>
										<translationTemplate ref="TR.resourceNotAccessibleException"/>
										<translationTemplate ref="TR.resourceNotAccessible"/>
										<translationTemplate ref="TR.unknownXMLResource"/>
										<translationTemplate ref="TR.unknownResourceType"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID6ae07702-e063-43a4-bf3f-c0d29696bcd2">
									<label>md-iso.d.3: Coupled resource</label>
									<description><![CDATA[<p>If the resource is a spatial data service, this metadata element refers to the target spatial data set(s) of the service. It is implemented by reference, i.e. through a URL that points to the metadata record of the data on which the service operates.</p>
<p>This test case only applies to records with a hierarchyLevel value 'service'.</p>
<p>The operatesOn element in the SV_ServiceIdentification element should be a HTTP URI that when retrieved using HTTP GET should return the metadata document describing the dataset exposed by this service (i.e. the resource must be a metadata record with a hierarchyLevel 'dataset' or 'series').</p>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/coupled-resource" target="_blank">Abstract Test Case 'Coupled resource'</a></p>]]></description>
									<parent ref="EID1c897122-b9cc-4d27-806e-e527630a23b1"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $recordsToInspect := $records[gmd:hierarchyLevel/gmd:MD_ScopeCode/@codeListValue = 'service' and gmd:identificationInfo/srv:SV_ServiceIdentification/srv:operatesOn]
let $urls := $recordsToInspect/gmd:identificationInfo/srv:SV_ServiceIdentification/srv:operatesOn/@xlink:href
let $map := local:check-resource-uris($urls, 30, true())
let $messages :=
	(for $record in $recordsToInspect
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $urls := $record/gmd:identificationInfo/srv:SV_ServiceIdentification/srv:operatesOn/@xlink:href
	 return
	 if (not($urls)) then
		local:addMessage('TR.operatesOnWithoutXlink', map { 'filename': local:filename($record), 'id': $rid })
	 else
		for $href in $urls
		let $url := string($href)
		let $validuri := map:get($map, $url)
		return
		if ($validuri = 'notHTTP') then
			local:addMessage('TR.urlNotHttp', map { 'filename': local:filename($record), 'id': $rid, 'url': $url })
		else if ($validuri = 'idNotFound') then
			local:addMessage('TR.idNotFound', map { 'filename': local:filename($record), 'id': $rid, 'url': $url })
      else if (starts-with($validuri, 'EXCEPTION')) then
	   	local:addMessage('TR.resourceNotAccessibleException', map { 'filename': local:filename($record), 'id': $rid, 'url': $url, 'message': substring-after($validuri, 'EXCEPTION ') })
		else if (matches($validuri,'^\d{3}$')) then
			local:addMessage('TR.resourceNotAccessible', map { 'filename': local:filename($record), 'id': $rid, 'url': $url, 'status' : $validuri })
		else if (starts-with($validuri,'text/xml') or starts-with($validuri,'application/xml')) then
			try {
				let $root := fn:doc($url)/element()
				return
				if ($root[//gmd:hierarchyLevel[1]/gmd:MD_ScopeCode/@codeListValue = ('dataset','series')]) then ()
				else local:addMessage('TR.operatesOnWithoutDatasetOrSeriesRecord', map { 'filename': local:filename($record), 'id': $rid, 'url': $url, 'hierarchyLevel': data($root//gmd:hierarchyLevel[1]/gmd:MD_ScopeCode/@codeListValue) })
			} catch * {
				local:addMessage('TR.resourceNotAccessibleException', map { 'filename': local:filename($record), 'id': $rid, 'url': $url, 'message': $err:description })
			}
		else
			local:addMessage('TR.unknownResourceType', map { 'filename': local:filename($record), 'id': $rid, 'url': $url, 'mediaType': $validuri })
	)[position() le $limitErrors]
return
(if ($messages//@ref = ('TR.operatesOnWithoutXlink','TR.resourceNotAccessible','TR.resourceNotAccessibleException','TR.idNotFound','TR.urlNotHttp','TR.operatesOnWithoutDatasetOrSeriesRecord')) then 'FAILED' else if ($messages) then 'PASSED_MANUAL' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
			      </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.operatesOnWithoutXlink"/>
										<translationTemplate ref="TR.urlNotHttp"/>
										<translationTemplate ref="TR.idNotFound"/>
										<translationTemplate ref="TR.resourceNotAccessibleException"/>
										<translationTemplate ref="TR.resourceNotAccessible"/>
										<translationTemplate ref="TR.operatesOnWithoutDatasetOrSeriesRecord"/>
										<translationTemplate ref="TR.unknownResourceType"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>
				<TestCase id="EID31ae1ae8-d291-4e4f-9241-6d8fdd2d4620">
					<label>Keywords</label>
					<description>The test on the existence of keywords is a pre-condition for other tests.</description>
					<parent ref="EID4c5d8006-3ac6-43d9-a1a3-1e19bf163ff3"/>
					<testSteps>
						<TestStep id="EID0a65ace3-6866-4b69-90f6-bc9cb7defbe3">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID31ae1ae8-d291-4e4f-9241-6d8fdd2d4620"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EIDe2459219-e13e-43ac-9cea-99d98225dd31">
									<label>md-iso.e.1: Keywords</label>
									<description><![CDATA[<p>Checks if at least one keyword element is provided and it is not an empty CharacterString.</p>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/keyword" target="_blank">Abstract Test Case 'Keyword'</a></p>]]></description>
									<parent ref="EID0a65ace3-6866-4b69-90f6-bc9cb7defbe3"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $messages :=
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $keywords := $record/gmd:identificationInfo[1]/*/gmd:descriptiveKeywords/*/gmd:keyword/*[1]
	 return
	 if (not($keywords)) then
		local:addMessage('TR.noKeywords', map { 'filename': local:filename($record), 'id': $rid })
	 else if ($keywords[string-length(normalize-space(text())) &gt; 0]) then ()
	 else local:addMessage('TR.emptyKeywords', map { 'filename': local:filename($record), 'id': $rid })
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.recordsWithErrors"/>
										<translationTemplate ref="TR.noKeywords"/>
										<translationTemplate ref="TR.emptyKeywords"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>
				<TestCase id="EIDb6ffab96-f0ac-45d9-ba73-9efce35d8f65">
					<label>Keywords - details</label>
					<description>Execute detailed tests on the keywords.</description>
					<parent ref="EID4c5d8006-3ac6-43d9-a1a3-1e19bf163ff3"/>
					<dependencies>
						<testCase ref="EID31ae1ae8-d291-4e4f-9241-6d8fdd2d4620"/>
					</dependencies>
					<testSteps>
						<TestStep id="EIDa445032d-1f63-47af-b100-edb86846d5d1">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EIDb6ffab96-f0ac-45d9-ba73-9efce35d8f65"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EIDdeecb600-6b6e-4fa3-a6df-4913055b3dd1">
									<label>md-iso.f.1: Dataset keyword</label>
									<description><![CDATA[<p>The test checks for each descriptiveKeywords block if it references either http://www.eionet.europa.eu/gemet/inspire_themes or any duplicate of that thesaurus, e.g. http://inspire.ec.europa.eu/theme. If a block is referencing that thesaurus the test checks if at least one keyword is available and it matches with a concept in the thesaurus.</p>
<p>This test case only applies to records with a hierarchyLevel value 'dataset' or 'series'.</p>
<p>The test first checks if a descriptiveKeywords block exists with vocabulary title (identified via gmd:thesaurusName/*/gmd:title/*/text()) equal to 'GEMET - INSPIRE themes, version 1.0'. If such a keyword block exists, then at least one keyword must be equal to one of the codes from the http://inspire.ec.europa.eu/theme codelist - either a language neutral code or one of the language specific code titles provided by the INSPIRE registry.</p>
<p>Relevant requirements:</p>
<ul>
<li>TG MD Requirement 14: If only one keyword is used, then for spatial dataset or spatial dataset series, the keyword:
<ul>
<li>shall describe the relevant INSPIRE Spatial Data Theme (as defined in Annex I, II and III of the INSPIRE Directive)</li>
<li>shall be expressed in the language of the metadata for the 34 INSPIRE Spatial Data Themes (please use the terms in each of the official languages in which the INSPIRE Directive has been translated) or a neutral language values such as a URI.</li>
</ul>
</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/ds-keyword" target="_blank">Abstract Test Case 'Dataset keywords'</a></p>]]></description>
									<parent ref="EIDa445032d-1f63-47af-b100-edb86846d5d1"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $THEMES_TITLE := 'GEMET'
let $recordsToInspect := $records[gmd:hierarchyLevel/gmd:MD_ScopeCode/@codeListValue = ('dataset','series')]
let $messages :=
	if (not($recordsToInspect)) then ()
	else
		try {
			let $officialLanguages := ('bg','cs','da','de','et','el','en','es','fr','hr','it','lv','lt','hu','mt','nl','pl','pt','ro','sk','sl','fi','sv')
			let $inspireThemesCodeListURL := 'http://inspire.ec.europa.eu/theme'
			let $codeTitles := local:get-code-titles($inspireThemesCodeListURL,$officialLanguages)
			let $codeValues := local:get-code-list-values($inspireThemesCodeListURL)
			let $codes := ($codeTitles,$codeValues)
			return
			(for $record in $recordsToInspect
			 let $rid := $record/gmd:fileIdentifier/*/text()
			 let $descriptiveKeywordsBlocks := $record/gmd:identificationInfo/*/gmd:descriptiveKeywords/*
			 let $relevantDescriptiveKeywordsBlocks := 
				for $descriptiveKeywordsBlock in $descriptiveKeywordsBlocks
				return if (contains($descriptiveKeywordsBlock/gmd:thesaurusName/*/gmd:title/*/text(), $THEMES_TITLE)) then 
					$descriptiveKeywordsBlock
				else ()
			 let $hasExpectedDate := boolean($relevantDescriptiveKeywordsBlocks/gmd:thesaurusName/*/gmd:date/*[gmd:date/*/text() = '2008-06-01' and gmd:dateType/*/@codeListValue = 'publication'])
			 return 

			 if (count($relevantDescriptiveKeywordsBlocks) = 0) then
				local:addMessage('TR.missingGEMETKeyword',  map { 'filename': local:filename($record), 'id': $rid })

			 else if (count($relevantDescriptiveKeywordsBlocks) > 0 and $relevantDescriptiveKeywordsBlocks[not(some $keyword in ./gmd:keyword/*/text() satisfies $keyword = $codes) ]) then
				local:addMessage('TR.noKeywordFromINSPIREThemes',  map { 'filename': local:filename($record), 'id': $rid, 'url': $inspireThemesCodeListURL, 'keywords': fn:string-join($relevantDescriptiveKeywordsBlocks/gmd:keyword/*/text(),'; ') })
			 else if (count($relevantDescriptiveKeywordsBlocks) > 0 and not($hasExpectedDate)) then
				local:addMessage('TR.invalidDateForThesaurusGemet',  map { 'filename': local:filename($record), 'id': $rid, 'keywords' : fn:string-join($relevantDescriptiveKeywordsBlocks/gmd:keyword/*/text(),'; ') })
			 else if (count($relevantDescriptiveKeywordsBlocks) > 0 and string-length(normalize-space($relevantDescriptiveKeywordsBlocks/gmd:thesaurusName/*/gmd:date/*/gmd:dateType/*/@codeListValue)) = 0) then
				local:addMessage('TR.emptyDateTypeCode',  map { 'filename': local:filename($record), 'id': $rid, 'keywords' : fn:string-join($relevantDescriptiveKeywordsBlocks/gmd:keyword/*/text(),'; ') })
			 else ()
			)[position() le $limitErrors]
		} catch * {
			local:addMessage('TR.systemError',  map { 'text': $err:description })
		}
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noKeywordFromINSPIREThemes"/>
										<translationTemplate ref="TR.invalidDateForThesaurusGemet"/>
										<translationTemplate ref="TR.emptyDateTypeCode"/>
										<translationTemplate ref="TR.missingGEMETKeyword"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID74984e66-5f25-4250-bea4-46c97c08910c">
									<label>md-iso.f.2: Service keyword</label>
									<description><![CDATA[<p>This test checks that each service metadata record has a keyword that defines the category of the service.</p>
<p>This test case only applies to records with a hierarchyLevel value 'service'.</p>
<p>If the resource is a service, at least one keyword must originate from <a href="http://inspire.ec.europa.eu/metadata-codelist/SpatialDataServiceCategory">EU commission regulation No. 1205/2008, Annex part D, No. 4</a>.</p>
<p>Relevant requirement(s):</p>
<ul>
<li>TG Requirement 15: For spatial services, the keyword:
<ul>
<li>shall at least define the category or subcategory of the service using its language neutral name as defined in Part D 4 of the INSPIRE Metadata Regulation 1205/2008/EC</li>
<li>shall be expressed as neutral language values such as the neutral language values defined in Part D.4 of the INSPIRE Metadata Regulation 1205/2008/EC for spatial data services)</li>
</ul>
</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/srv-keyword" target="_blank">Abstract Test Case 'Service keyword'</a></p>]]></description>
									<parent ref="EIDa445032d-1f63-47af-b100-edb86846d5d1"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
 let $recordsToInspect := $records[gmd:hierarchyLevel/gmd:MD_ScopeCode/@codeListValue = 'service']
 let $messages :=
	 if (not($recordsToInspect)) then ()
	 else
		 try {
			 let $spatialDataServiceCategoriesCodeListURL := 'http://inspire.ec.europa.eu/metadata-codelist/SpatialDataServiceCategory'
			 let $codes := local:get-code-list-values($spatialDataServiceCategoriesCodeListURL)
			 return
			 (for $record in $recordsToInspect
			  let $rid := $record/gmd:fileIdentifier/*/text()
			  let $keywords := $record/gmd:identificationInfo[1]/*/gmd:descriptiveKeywords/*/gmd:keyword/*/text()
			  return
			  if (not(some $keyword in $keywords satisfies $keyword = $codes)) then
			 	local:addMessage('TR.noKeywordFromSpatialDataServiceCategory',  map { 'filename': local:filename($record), 'id': $rid, 'url': $spatialDataServiceCategoriesCodeListURL, 'keywords': fn:string-join($keywords,'; ') })
			  else ()
			 )[position() le $limitErrors]
		 } catch * {
			 local:addMessage('TR.systemError',  map { 'text': $err:description })
		 }
 return
 (if ($messages//@ref = ('TR.noKeywordFromSpatialDataServiceCategory','TR.systemError')) then 'FAILED' else 'PASSED',
  local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
  $messages)
			      </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noKeywordFromSpatialDataServiceCategory"/>
										<translationTemplate ref="TR.systemError"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID3b4a230e-e3e0-4ef4-8080-172c78c5886e">
									<label>md-iso.f.3: Keywords in vocabulary grouped</label>
									<description><![CDATA[<p>The test checks that keyword values originating from a single version of a single controlled vocabulary are grouped in a single instance.</br></br>
Relevant requirement(s):</p>
<ul>
<li>TG MD Requirement 19: In order to be consistent with ISO 19115, all the keyword values originating from a single version of a single controlled vocabulary shall be grouped in a single instance of the ISO 19115 descriptiveKeywords property.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/keywords-in-vocabulary" target="_blank">Abstract Test Case 'Keywords in vocabulary'</a></p>]]></description>
									<parent ref="EIDa445032d-1f63-47af-b100-edb86846d5d1"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $messages :=
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $thesaurusTitles := $record/gmd:identificationInfo[1]/*/gmd:descriptiveKeywords/*/gmd:thesaurusName/*/gmd:title/*[1]/text()
	 let $duplicateTitles := $thesaurusTitles[index-of($thesaurusTitles,.)[2]]
	 return
	 if (count($duplicateTitles) &gt; 0) then
		local:addMessage('TR.controlledVocabularyNotUnique',  map { 'filename': local:filename($record), 'id': $rid, 'duplicates': string-join($duplicateTitles,', ') })
	 else ()
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.controlledVocabularyNotUnique"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
								<TestAssertion id="EID99f6e123-0d0d-475f-8bba-cdcb5cc402e0">
									<label>md-iso.f.4: Vocabulary information</label>
									<description><![CDATA[<p>A keyword may contain a reference to a controlled vocabulary from where it originates. This element is optional but, if given, must follow certain guidelines.</p>
<p>The test performs the following check for each vocabulary:</p>
<ul>
<li>the node must contain a title and not be an empty characterstring</li>
<li>the node must contain a date</li>
<li>the node must contain a dateType which contains text that equals one of 'publication', 'revision' or 'creation'.</li>
</ul>
<p>Relevant requirement(s):</p>
<ul>
<li>TG MD Requirement 17: If  the  keyword  value  originates  from  a  controlled  vocabulary (thesaurus, ontology), for example GEMET - Concepts, the citation of the originating controlled vocabulary shall be provided.</li>
<li>TG MD Requirement 18: The thesaurusName identification shall include at least the title and a reference date (date of publication, date of last revision or of creation) of the originating controlled vocabulary.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/vocabulary" target="_blank">Abstract Test Case 'Vocabulary'</a></p>]]></description>
									<parent ref="EID95a1a8a8-3132-453f-921a-c0334781e8bb"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $messages :=
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $thesauri := $record/gmd:identificationInfo[1]/*/gmd:descriptiveKeywords/*/gmd:thesaurusName
	 return
	 if (not($thesauri)) then ()
	 else for $thesaurus in $thesauri
		let $title := $thesaurus/*/gmd:title/*[1]/text()
		let $keywords := string-join($thesaurus/../gmd:keyword/*[1]/text(), '; ')
		let $hasExpectedDate := boolean($thesaurus/*/gmd:date/*[gmd:date/*/text() and gmd:dateType/*/@codeListValue = ('publication','revision','creation')])
		return
		(if (not($title)) then local:addMessage('TR.noTitleForThesaurus', map { 'filename': local:filename($record), 'id': $rid, 'keywords' : $keywords })
		 else if (string-length(normalize-space($title)) = 0) then local:addMessage('TR.emptyTitleForThesaurus', map { 'filename': local:filename($record), 'id': $rid, 'keywords' : $keywords })
		 else (),
		 if (not($hasExpectedDate)) then local:addMessage('TR.invalidDateForThesaurus', map { 'filename': local:filename($record), 'id': $rid, 'thesaurus': if ($title) then $title else '', 'keywords' : $keywords }) else ()
		)
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.noTitleForThesaurus"/>
										<translationTemplate ref="TR.emptyTitleForThesaurus"/>
										<translationTemplate ref="TR.invalidDateForThesaurus"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>
				<TestCase id="EID6c1bd65c-f4e5-42cc-a007-fe6593536d2c">
					<label>Temporal extent</label>
					<description>The test on the temporal extent is a pre-condition for other tests.</description>
					<parent ref="EID4c5d8006-3ac6-43d9-a1a3-1e19bf163ff3"/>
					<testSteps>
						<TestStep id="EID35c8e53d-0947-43de-a410-8c34eac54e33">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID6c1bd65c-f4e5-42cc-a007-fe6593536d2c"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EID163c7a80-2288-462f-a1c9-0973b5f96d40">
									<label>md-iso.g.1: Temporal extent</label>
									<description><![CDATA[<p>This test performs the following checks:</p>
<ul>
<li>Check if a TimePeriod element exists and if it contains gml:begin or gml:end elements, then the element value (a gml:TimeInstant) is provided inline.</li>
<li>Check that at least one temporal reference with dateType = 'publication', 'creation', or 'revision' exists.</li>
</ul>
<p>The test fails if either of these conditions is not fulfilled.</p>
<p>Relevant requirement(s):</p>
<ul>
<li>TG MD Requirement 22: The INSPIRE Metadata Regulation 1205/2008/EC requires at least one temporal reference chosen from one of these four categories:
<ul>
<li>temporal extent</li>
<li>date of publication</li>
<li>date of last revision</li>
<li>date of creation</li>
</ul>
</li>
<li>TG MD Requirement 23: To be compliant with ISO 19115 it is necessary to use at least one among date of publication, date of last revision, or the date of creation.</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/ds-temporal" target="_blank">Abstract Test Case 'Dataset temporal'</a></p>]]></description>
									<parent ref="EID35c8e53d-0947-43de-a410-8c34eac54e33"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $messages :=
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $timePeriods := $record/gmd:identificationInfo[1]/*/*[self::gmd:extent or self::srv:extent]/*/gmd:temporalElement/*/gmd:extent/*[self::gml:TimePeriod or self::gml31:TimePeriod]
	 let $invalidTimePeriods :=
		for $timePeriod in $timePeriods
		return
		if (not($timePeriod[(not(*:begin) or *:begin/*:TimeInstant) and (not(*:end) or *:end/*:TimeInstant)])) then $timePeriod
		else ()
	 let $temporalReferences := $record/gmd:identificationInfo[1]/*/gmd:citation/*/gmd:date/*
	 let $relevantTempRefs := $temporalReferences[gmd:dateType/*/@codeListValue = ('publication','revision','creation')]
	 return
	 if ($invalidTimePeriods) then
		local:addMessage('TR.timePeriodWithoutInlineTimeInstant', map { 'filename': local:filename($record), 'id': $rid })
	 else if(not($relevantTempRefs)) then
		local:addMessage('TR.noRelevantDate', map { 'filename': local:filename($record), 'id': $rid })
	 else ()
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
							  </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.timePeriodWithoutInlineTimeInstant"/>
										<translationTemplate ref="TR.noRelevantDate"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>
				<TestCase id="EID455b0d39-ee9f-4f5a-a15e-2b264e57bb62">
					<label>Temporal extent - details</label>
					<description>Execute detailed tests on the temporal extent.</description>
					<parent ref="EID4c5d8006-3ac6-43d9-a1a3-1e19bf163ff3"/>
					<dependencies>
						<testCase ref="EID6c1bd65c-f4e5-42cc-a007-fe6593536d2c"/>
					</dependencies>
					<testSteps>
						<TestStep id="EID96ea0d7d-3115-4dd2-af86-82c788085239">
							<label>IGNORE</label>
							<description>IGNORE</description>
							<parent ref="EID455b0d39-ee9f-4f5a-a15e-2b264e57bb62"/>
							<statementForExecution>not applicable</statementForExecution>
							<testItemType ref="EIDf483e8e8-06b9-4900-ab36-adad0d7f22f0"/>
							<testAssertions>
								<TestAssertion id="EID981aa1f9-4c82-48eb-9761-dbe45e6a19f6">
									<label>md-iso.h.1: Temporal date</label>
									<description><![CDATA[<p>The test checks that dates are expressed in accordance with ISO 8601:</p>
<ul>
<li>Begin and end of a TimePeriod must be valid dates (xs:date or xs:dateTime).</li>
<li>An @frame attribute is not allowed on a beginPosition or endPosition of a gml:TimePeriod.</li>
<li>A date of 'publication', 'creation', or 'revision' must be valid (xs:date or xs:dateTime).</li>
</ul>
<p>Relevant requirement(s):</p>
<ul>
<li>TG MD Requirement 24: The default reference system shall be the Gregorian calendar, with dates expressed in accordance with ISO 8601 (yyyy-mm-dd where yyyy is the year, mm is the month and dd is the day).</li>
</ul>
<p>Source: <a href="http://inspire.ec.europa.eu/id/ats/metadata/1.3/iso-19115-19119/ds-temporal-date" target="_blank">Abstract Test Case 'Dataset temporal date'</a></p>]]></description>
									<parent ref="EID96ea0d7d-3115-4dd2-af86-82c788085239"/>
									<expectedResult>NOT_APPLICABLE</expectedResult>
									<expression>
let $messages :=
	(for $record in $records
	 let $rid := $record/gmd:fileIdentifier/*/text()
	 let $timePeriods := $record/gmd:identificationInfo[1]/*/*[self::gmd:extent or self::srv:extent]/*/gmd:temporalElement/*/gmd:extent/*[self::gml:TimePeriod or self::gml31:TimePeriod]
	 let $invalidTimePeriods :=
		for $timePeriod in $timePeriods
		let $beginDate := ($timePeriod/*:begin/*:TimeInstant/*:timePosition/text(), $timePeriod/*:beginPosition/text())
		let $endDate := ($timePeriod/*:end/*:TimeInstant/*:timePosition/text(), $timePeriod/*:endPosition/text())
		(: NOTE: we exclude the case in which a gml:begin or gml:end references the gml:TimeInstant; this situation is checked by another test that this test depends upon :)
		let $validDate := (not($beginDate) or local:is-valid-date-or-dateTime($beginDate)) and (not($endDate) or local:is-valid-date-or-dateTime($endDate))
		return
		if ($validDate) then ()
		else $timePeriod
	 let $frameOnBeginPosition := boolean($timePeriods/*:beginPosition/*/@frame)
	 let $frameOnEndPosition := boolean($timePeriods/*:endPosition/*/@frame)
	 let $frameOnPeriod := boolean($timePeriods/@frame)
	 let $frameOnInstant := boolean($timePeriods/*:begin/*/@frame | $timePeriods/*:end/*/*:timePosition/@frame)
	 let $frameOnTimePosition := boolean($timePeriods/*:begin/*/@frame | $timePeriods/*:end/*/*:timePosition/@frame)
	 let $relevantDates := $record/gmd:identificationInfo[1]/*/gmd:citation/*/gmd:date/*[gmd:dateType/*/@codeListValue = ('publication','revision','creation')]/gmd:date/*
	 let $invalidRelevantDates :=
		for $relevantDate in $relevantDates
		let $validDate := local:is-valid-date-or-dateTime($relevantDate)
		return
		if ($validDate) then ()
		else $relevantDate
	 return
	 (if ($invalidTimePeriods) then
	 	let $invalidDates :=
			for $timePeriod in $timePeriods
			let $beginDate := ($timePeriod/*:begin/*:TimeInstant/*:timePosition/text(), $timePeriod/*:beginPosition/text())
			let $endDate := ($timePeriod/*:end/*:TimeInstant/*:timePosition/text(), $timePeriod/*:endPosition/text())
			return
			(if (local:is-valid-date-or-dateTime($beginDate)) then () else $beginDate,
			 if (local:is-valid-date-or-dateTime($endDate)) then () else $endDate)
		return
 		local:addMessage('TR.timePeriodWithInvalidDate', map { 'filename': local:filename($record), 'id': $rid, 'dates': fn:string-join($invalidDates, ', ') }) else (),
	  if ($frameOnBeginPosition) then
 		local:addMessage('TR.timePeriodWithFrameOnBeginPosition', map { 'filename': local:filename($record), 'id': $rid }) else (),
	  if ($frameOnEndPosition) then
		local:addMessage('TR.timePeriodWithFrameOnEndPosition', map { 'filename': local:filename($record), 'id': $rid }) else (),
	  if ($frameOnPeriod) then
		local:addMessage('TR.timePeriodWithFrame', map { 'filename': local:filename($record), 'id': $rid }) else (),
	  if ($frameOnInstant) then
		local:addMessage('TR.timePeriodWithFrameOnTimeInstant', map { 'filename': local:filename($record), 'id': $rid }) else (),
	  if ($frameOnTimePosition) then
		local:addMessage('TR.timePeriodWithFrameOnTimePosition', map { 'filename': local:filename($record), 'id': $rid }) else (),
	  if ($invalidRelevantDates) then
		local:addMessage('TR.invalidRelevantDate', map { 'filename': local:filename($record), 'id': $rid, 'dates': fn:string-join($relevantDates, ', ') }) else ())
	)[position() le $limitErrors]
return
(if ($messages) then 'FAILED' else 'PASSED',
 local:error-statistics('TR.recordsWithErrors', count(fn:distinct-values($messages//etf:argument[@token='id']/text()))),
 $messages)
			      </expression>
									<testItemType ref="EIDf0edc596-49d2-48d6-a1a1-1ac581dcde0a"/>
									<translationTemplates>
										<translationTemplate ref="TR.timePeriodWithInvalidDate"/>
										<translationTemplate ref="TR.timePeriodWithFrameOnBeginPosition"/>
										<translationTemplate ref="TR.timePeriodWithFrameOnEndPosition"/>
										<translationTemplate ref="TR.timePeriodWithFrame"/>
										<translationTemplate ref="TR.timePeriodWithFrameOnTimeInstant"/>
										<translationTemplate ref="TR.timePeriodWithFrameOnTimePosition"/>
										<translationTemplate ref="TR.invalidRelevantDate"/>
										<translationTemplate ref="TR.recordsWithErrors"/>
									</translationTemplates>
								</TestAssertion>
							</testAssertions>
						</TestStep>
					</testSteps>
				</TestCase>
			</testCases>
		</TestModule>
	</testModules>
</ExecutableTestSuite>
